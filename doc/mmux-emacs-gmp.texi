\input texinfo.tex
@c %**start of header
@setfilename mmux-emacs-gmp.info
@settitle MMUX Emacs GMP
@c %**end of header

@include version.texi
@include macros.texi
@include elisp-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX Emacs GMP

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX Emacs GMP

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-emacs-gmp

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2020, 2024

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_EMACS_GMP
@set PackagePkgconfigModule             @code{mmux-emacs-gmp}
@set PackageLibsVar                     @env{MMUX_EMACS_GMP_LIBS}
@set PackageCflagsVar                   @env{MMUX_EMACS_GMP_CFLAGS}

@set PackageLibstem                     @file{mmux-emacs-gmp}
@set PackageSharedLibraryBasename       @file{libmmux-emacs-gmp}

@set PackageEmacsModule                 @file{mmux-emacs-gmp}
@set PackageHeader                      mmux-emacs-gmp.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set PackageApiCPrefixLower             mmux_emacs_gmp_
@set PackageApiCPrefixUpper             MMUX_EMACS_GMP_
@set PackageApiElispPrefix              mmux-gmp-

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set GMPversion                 6.2.0+

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro gmpref{NODE, TITLE}
@xref{\NODE\,\TITLE\,\TITLE\,gmp}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a @gnu{} Emacs module
implemented on top of a C11 language library, providing an interface to the @gmp{} library.

The library supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
26+ and @gmp{} version @value{GMPversion}.  This package depends upon the external packages:
@samp{cl-lib}.  To run the test suite: this package requires the ERT package.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-emacs-gmp: (mmux-emacs-gmp).       MMUX Emacs GMP, an interface to GMP.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* integers::                    Exact integer objects and operations.
* rationals::                   Rational number objects and operations.
* floats::                      Floating-point number objects and operations.
* random::                      Random numbers generation.
* errors::                      How errors are signalled.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* modules: (elisp)Writing Dynamic Modules.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a @gnu{} Emacs module
implemented on top of a C11 language library, providing an interface to the @gmp{} library.

The library supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
26+ and @gmp{} version @value{GMPversion}.  This package depends upon the external packages:
@samp{cl-lib}.  To run the test suite: this package requires the ERT package.

@value{PACKAGE} installs a single elisp module @value{PackageEmacsModule} and a C language shared
library with basename @value{PackageSharedLibraryBasename} (using the @gnu{} Libtool
infrastructure).  All the elisp definition names are prefixed with either
@code{@value{PackageApiElispPrefix}}, @samp{gmp-}, @samp{mpz-}, @samp{mpq-} or @samp{mpf-}.  The C
language shared library is installed under @samp{$libdir}, for example:

@center @file{/usr/local/lib64}

@noindent
while the elisp module goes under @samp{$lispdir}, for example:

@center @file{/usr/local/share/emacs/site-lisp}

@noindent
so to load the module (under an Emacs installation with dynamic modules enabled) we should do
something like:

@lisp
(add-to-list 'load-path "/usr/local/lib64"
                        "/usr/local/share/emacs/site-lisp")
(require 'gmp)
@end lisp

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
It might be possible that we want to write a C language library making use of the facilities of this
package; so @value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the C
language function names in the @api{} are prefixed with @code{@value{PackageApiCPrefixLower}}; all
the C language preprocessor symbol names are prefixed with @code{@value{PackageApiCPrefixUpper}};
all the type names are prefixed with @code{@value{PackageApiCPrefixLower}} and suffixed with
@code{_t}.

Most of the functions implemented by @gmp{} are wrapped by @value{PACKAGE}, with the exclusion of
the initialisation functions and some other functions.  The elisp function names are equal to the C
language function names, with each underscore turned into a dash; so @cfunc{mpz_get_str} becomes
@func{mpz-get-str}.  Only a brief description of the arguments is given in this document: for the
full meaning of the function arguments we should refer to the original @gmp{} documentation.

@menu
* overview linking::            Linking code with the library.
@end menu

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@defun mmux-gmp-version-string
Return a string representing the interface version number.
@end defun


@defun mmux-gmp-version-interface-current
Return an integer representing the library interface current number.
@end defun


@defun mmux-gmp-version-interface-revision
Return an integer representing the library interface current revision number.
@end defun


@defun mmux-gmp-version-interface-age
Return an integer representing the library interface current age.
@end defun


@deftypefun {char const *} mmux_emacs_gmp_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_emacs_gmp_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_emacs_gmp_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_emacs_gmp_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node integers
@chapter Exact integer objects and operations


@deftp {Object Type} mpz
Type of structures representing a multiple precision exact integer.  It is a wrapper for the C
language type @objtype{mpz_t}.  These objects, and their internal representation, are correctly
garbage collected.
@end deftp


@menu
* integers allocation::         Allocating exact integers.
* integers predicates::         Exact integer predicates.
* integers assignment::         Assigning values to objects.
* integers conversion::         Converting exact integers to
                                other objects.
* integers arithmetic::         Arithmetic operations.
* integers division::           Division operations.
* integers exponentiation::     Exponentiation operations.
* integers roots::              Root extraction functions.
* integers comparison::         Commparison functions.
* integers theoretic::          Number theoretic functions.
* integers bitlogic::           Logical and bit manipulation functions.
* integers random::             Random number functions.
* integers miscellaneous::      Miscellaneous functions.
@end menu

@c page
@node integers allocation
@section Allocating exact integers


@defun mpz &optional @var{INIT}
Build and return a new @objtype{mpz} object instance.  When called with no arguments: the object is
uninitialised.

When the @var{INIT} argument is provided: it must be an initialisation value for the @objtype{mpz}
object.  I can be: an exact integer number; a floating--point number; an @objtype{mpz} object; an
@objtype{mpq} object; an @objtype{mpf} object.

When the @var{INIT} argument is missing: the returned object is initialised to zero.
@end defun

@c page
@node integers predicates
@section Exact integer predicates


@defun mpz-p @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{mpz}; otherwise return @false{}.

@lisp
(mpz-p (mpz))   @result{} t
(mpz-p 123)     @result{} nil
@end lisp
@end defun

@c page
@node integers assignment
@section Assigning values to objects


@deffn {Generic Function} mpz-set (@var{ROP} @var{OP})
@deffnx {Method} mpz-set ((@var{ROP} mpz) (@var{OP} mpz))
Assign the value of @var{OP} to @var{ROP}; both the operands must be of type @objtype{mpz}.

@lisp
(defconst rop (mpz))
(defconst op  (mpz))

(mpz-set-si rop 123)
(mpz-set    op rop)
(mpz-get-str 10 op)     @result{} "123"
@end lisp
@end deffn


@deffn {Generic Function} mpz-set-si (@var{ROP} @var{INT})
@deffnx {Method} mpz-set-si ((@var{ROP} mpz) (@var{INT} integer))
Assign the value of an exact integer object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))

(mpz-set-si rop 123)
(mpz-get-str 10 op)     @result{} "123"
@end lisp
@end deffn


@deffn {Generic Function} mpz-set-d (@var{ROP} @var{FLO})
@deffnx {Method} mpz-set-d ((@var{ROP} mpz) (@var{FLO} float))
Assign the value of a floating--point object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))

(mpz-set-d rop 12.3)
(mpz-get-str 10 rop)    @result{} "12"
@end lisp
@end deffn


@deffn {Generic Function} mpz-set-q (@var{ROP} @var{OP})
@deffnx {Method} mpz-set-q ((@var{ROP} mpz) (@var{OP} mpq))
Assign the value of an @objtype{mpq} object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))
(defconst op  (mpq))

(mpq-set-si op 10 7)
(mpz-set-q rop op)
(mpz-get-str 10 rop)    @result{} "1"
@end lisp
@end deffn


@deffn {Generic Function} mpz-set-f (@var{ROP} @var{OP})
@deffnx {Method} mpz-set-f ((@var{ROP} mpz) (@var{OP} mpf))
Assign the value of an @objtype{mpf} object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))
(defconst op  (mpf))

(mpf-set-d op 12.34)
(mpz-set-f rop op)
(mpz-get-str 10 rop)    @result{} "12"
@end lisp
@end deffn


@deffn {Generic Function} mpz-set-str (@var{ROP} @var{STR} @var{BASE})
@deffnx {Method} mpz-set-str ((@var{ROP} mpz) (@var{STR} string) (@var{BASE} integer))
Assign the value of a string object to an @objtype{mpz} object.  The argument @var{BASE} must be an
exact integer representing the base of the numeric string representation: @math{0} or a value
between @math{2} and @math{32}.

@lisp
(defconst rop (mpz))

(mpz-set-str rop "123" 10)
(mpz-get-str 10 rop)    @result{} "123"
@end lisp
@end deffn


@deffn {Generic Function} mpz-swap (@vari{OP} @varii{OP})
@deffnx {Method} mpz-swap ((@vari{OP} mpz) (@varii{OP} mpz))
Swap the values between two @objtype{mpz} objects.

@lisp
(defconst op1 (mpz))
(defconst op2 (mpz))

(mpz-set-si op1 123)
(mpz-set-si op2 456)
(mpz-swap op1 op2)
(mpz-get-str 10 op1)  @result{} "456"
(mpz-get-str 10 op2)  @result{} "123"
@end lisp
@end deffn

@c page
@node integers conversion
@section Converting exact integers to other objects


@deffn {Generic Function} mpz-get-ui (@var{OP})
@deffnx {Method} mpz-get-ui ((@var{OP} mpz))
Convert an object @var{OP} of type @objtype{mpz} to an unsigned exact integer number.

@lisp
(mpz-get-ui (mpz 123))  @result{} 123
@end lisp
@end deffn


@deffn {Generic Function} mpz-get-si (@var{OP})
@deffnx {Method} mpz-get-si ((@var{OP} mpz))
Convert an object @var{OP} of type @objtype{mpz} to an signed exact integer number.

@lisp
(mpz-get-si (mpz 123))  @result{} 123
@end lisp
@end deffn


@deffn {Generic Function} mpz-get-d (@var{OP})
@deffnx {Method} mpz-get-d ((@var{OP} mpz))
Convert an object @var{OP} of type @objtype{mpz} to a floating--point number.

@lisp
(mpz-get-d (mpz 123))  @result{} 123.0
@end lisp
@end deffn


@deffn {Generic Function} mpz-get-d-2exp (@var{OP})
@deffnx {Method} mpz-get-d-2exp ((@var{OP} mpz))
Convert an object @var{OP} of type @objtype{mpz} to a floating--point number, yielding the exponent
separately.  The return value is a pair whose car is a floating--point number and whose cdr is the
exponent:

@lisp
(defconst rv (mpz-get-d-2exp (mpz 123)))

rv                                      @result{} (0.9609375 . 7)
(* (car rv) (expt 2 (cdr rv)))          @result{} 123.0
@end lisp
@end deffn


@deffn {Generic Function} mpz-get-str (@var{BASE} @var{OP})
@deffnx {Method} mpz-get-str ((@var{BASE} integer) (@var{OP} mpz))
Convert an object @var{OP} of type @objtype{mpz} to a string; return the resulting string.
@var{BASE} must be an exact integer representing the base of the numeric string representation:
positive between @math{2} and @math{36} or negative between @math{-2} and @math{-36}.

@lisp
(defconst op (mpz))
(mpz-set-si op 15)
(mpz-get-str  10 op)    @result{} "15"
(mpz-get-str  16 op)    @result{} "f"
(mpz-get-str -16 op)    @result{} "F"
@end lisp
@end deffn

@c page
@node integers arithmetic
@section Arithmetic operations


@deffn {Generic Function} mpz-add (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-add ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Add two @objtype{mpz} objects.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 10))
      (op2      (mpz 1)))
  (mpz-add rop op1 op2)
  (mpz-get-ui rop))
@result{} 11
@end lisp
@end deffn


@deffn {Generic Function} mpz-add-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-add-ui ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} integer))
Add an @objtype{mpz} object to an unsigned exact integer number.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 10))
      (op2      1))
  (mpz-add-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} 11
@end lisp
@end deffn


@deffn {Generic Function} mpz-sub (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-sub ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Subtract two @objtype{mpz} objects.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 11))
      (op2      (mpz 1)))
  (mpz-sub rop op1 op2)
  (mpz-get-ui rop))
@result{} 10
@end lisp
@end deffn


@deffn {Generic Function} mpz-sub-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-sub-ui ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} integer))
Subtract an unsigned exact integer number from an @objtype{mpz} object.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 11))
      (op2      1))
  (mpz-sub-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} 10
@end lisp
@end deffn


@deffn {Generic Function} mpz-addmul (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-addmul ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Multiply two @objtype{mpz} objects, then add the result to another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     (mpz 2)))
  (mpz-addmul rop op1 op2)
  (mpz-get-ui rop))
@result{} (+ 100 (* 11 2))
@end lisp
@end deffn


@deffn {Generic Function} mpz-addmul-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-addmul-ui ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} integer))
Multiply an @objtype{mpz} object with an unsigned exact integer number, then add the result to
another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     2))
  (mpz-addmul-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} (+ 100 (* 11 2))
@end lisp
@end deffn


@deffn {Generic Function} mpz-submul (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-submul ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Multiply two @objtype{mpz} objects, then subtract the result from another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     (mpz 2)))
  (mpz-submul rop op1 op2)
  (mpz-get-ui rop))
@result{} (- 100 (* 11 2))
@end lisp
@end deffn


@deffn {Generic Function} mpz-submul-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-submul-ui ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} integer))
Multiply an @objtype{mpz} object with an unsigned exact integer number, then subtract the result
from another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     2))
  (mpz-submul-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} (- 100 (* 11 2))
@end lisp
@end deffn


@deffn {Generic Function} mpz-mul (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-mul ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Multiply two @objtype{mpz} objects.

@lisp
(let ((rop     (mpz))
      (op1     (mpz 111))
      (op2     (mpz 2)))
  (mpz-mul rop op1 op2)
  (mpz-get-ui rop))
@result{} 222
@end lisp
@end deffn


@deffn {Generic Function} mpz-mul-si (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-mul-si ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} integer))
Multiply an @objtype{mpz} object by a signed exact integer number.

@lisp
(let ((rop     (mpz))
      (op1     (mpz 111))
      (op2     2))
  (mpz-mul-si rop op1 op2)
  (mpz-get-ui rop))
@result{} 222
@end lisp
@end deffn


@deffn {Generic Function} mpz-mul-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-mul-ui ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} integer))
Multiply an @objtype{mpz} object by an unsigned exact integer number.

@lisp
(let ((rop     (mpz))
      (op1     (mpz 111))
      (op2     2))
  (mpz-mul-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} 222
@end lisp
@end deffn


@deffn {Generic Function} mpz-mul-2exp (@var{ROP} @var{OP} @var{bitcnt})
@deffnx {Method} mpz-mul-2exp ((@var{ROP} mpz) (@var{OP} mpz) (@var{bitcnt} integer))
Left shift an @objtype{mpz} object.

@lisp
(let ((rop     (mpz))
      (op      (mpz #b10101))
      (bitcnt  2))
  (mpz-mul-2exp rop op bitcnt)
  (mpz-get-ui rop))
@result{} #b1010100
@end lisp
@end deffn


@deffn {Generic Function} mpz-neg (@var{ROP} @var{OP})
@deffnx {Method} mpz-neg ((@var{ROP} mpz) (@var{OP} mpz))
Negate an @objtype{mpz} object.

@lisp
(let ((rop     (mpz))
      (op      (mpz 123)))
  (mpz-neg rop op)
  (mpz-get-si rop))
@result{} -123
@end lisp
@end deffn


@deffn {Generic Function} mpz-abs (@var{ROP} @var{OP})
@deffnx {Method} mpz-abs ((@var{ROP} mpz) (@var{OP} mpz))
Compute the absolute value of an @objtype{mpz} object.

@lisp
(let ((rop     (mpz))
      (op      (mpz -123)))
  (mpz-abs rop op)
  (mpz-get-ui rop))
@result{} 123
@end lisp
@end deffn

@c page
@node integers division
@section Division operations


The division functions divide numerator @math{N} by the denominator @math{D}, forming a quotient
@math{Q} and/or remainder @math{R}; for the @code{2exp} functions, @math{D=2^B} where @math{B} is
the bit count.  The rounding is in three styles, each suiting different applications.

@table @code
@item cdiv
Rounds @math{Q} up towards +infinity, and @math{R} will have the opposite sign to @math{D}.  The
@code{c} stands for ``ceil''.

@item fdiv
Rounds @math{Q} down towards -infinity, and @math{R} will have the same sign as @math{D}.  The @code{f}
stands for ``floor''.

@item tdiv
Rounds @math{Q} towards zero, and @math{R} will have the same sign as @math{N}.  The @code{t} stands
for ``truncate''.
@end table

In all cases @math{Q} and @math{R} will satisfy @math{N = Q * D + R}, and @math{R} will satisfy
@math{0 <= abs(R) < abs(D)}.

@menu
* integers division ceil::      Rounding towards +infinity (ceil).
* integers division floor::     Rounding towards -infinity (floor).
* integers division truncate::  Rounding towards zero (truncate).
* integers division modulo::    Modulo functions.
* integers division exact::     Exact division.
@end menu

@c page
@node integers division ceil
@subsection Rounding towards +infinity (ceil)


For the examples in this section, remember that the template operation is:

@example
N = Q * D + R
@end example

@noindent
and with ceil rounding we have:

@example
N = 10
D = 3
Q = ceil(N/D) = ceil(10 / 3) = ceil(3.33333) = 4
R = N - Q * D = 10 - 4 * 3 = -2
@end example

@noindent
for the @code{2exp} functions:

@example
N = 10
B = 3
D = 2^B = 2^3 = 8
Q = ceil(N/D) = ceil(10 / 8) = ceil(1.25) = 2
R = N - Q * D = 10 - 2 * 8 = 10 - 16 = -6
@end example


@deffn {Generic Function} mpz-cdiv-q (@var{Q} @var{N} @var{D})
@deffnx {Method} mpz-cdiv-q ((@var{Q} mpz) (@var{N} mpz) (@var{D} mpz))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-cdiv-q Q N D)
  (mpz-get-si Q))
@result{} 4
@end lisp
@end deffn


@deffn {Generic Function} mpz-cdiv-r (@var{R} @var{N} @var{D})
@deffnx {Method} mpz-cdiv-r ((@var{R} mpz) (@var{N} mpz) (@var{D} mpz))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-cdiv-r R N D)
  (mpz-get-si R))
@result{} -2
@end lisp
@end deffn


@deffn {Generic Function} mpz-cdiv-qr (@var{Q} @var{R} @var{N} @var{D})
@deffnx {Method} mpz-cdiv-qr ((@var{Q} mpz) (@var{R} mpz) (@var{N} mpz) (@var{D} mpz))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-cdiv-qr Q R N D)
  (mpz-get-si Q)        @result{} +4
  (mpz-get-si R))       @result{} -2
@end lisp
@end deffn


@deffn {Generic Function} mpz-cdiv-q-ui (@var{Q} @var{N} @var{D})
@deffnx {Method} mpz-cdiv-q-ui ((@var{Q} mpz) (@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-cdiv-q-ui Q N D)))
    (mpz-get-si Q)      @result{} +4
    absR))              @result{} +2
@end lisp
@end deffn


@deffn {Generic Function} mpz-cdiv-r-ui (@var{R} @var{N} @var{D})
@deffnx {Method} mpz-cdiv-r-ui ((@var{R} mpz) (@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-cdiv-r-ui R N D)))
    (mpz-get-si R)      @result{} -2
    absR))              @result{} +2
@end lisp
@end deffn


@deffn {Generic Function} mpz-cdiv-qr-ui (@var{Q} @var{R} @var{N} @var{D})
@deffnx {Method} mpz-cdiv-qr-ui ((@var{Q} mpz) (@var{R} mpz) (@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-cdiv-qr-ui Q R N D)))
    (mpz-get-si Q)      @result{} +4
    (mpz-get-si R)      @result{} -2
    absR))              @result{} +2
@end lisp
@end deffn


@deffn {Generic Function} mpz-cdiv-ui (@var{N} @var{D})
@deffnx {Method} mpz-cdiv-ui ((@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((N      (mpz 10))
      (D      3))
  (mpz-cdiv-ui N D))    @result{} +2
@end lisp
@end deffn


@deffn {Generic Function} mpz-cdiv-q-2exp (@var{Q} @var{N} @var{B})
@deffnx {Method} mpz-cdiv-q-2exp ((@var{Q} mpz) (@var{N} mpz) (@var{B} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-cdiv-q-2exp Q N B)
  (mpz-get-si Q))
@result{} +2
@end lisp
@end deffn


@deffn {Generic Function} mpz-cdiv-r-2exp (@var{R} @var{N} @var{B})
@deffnx {Method} mpz-cdiv-r-2exp ((@var{R} mpz) (@var{N} mpz) (@var{B} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-cdiv-r-2exp R N B)
  (mpz-get-si R))
@result{} -6
@end lisp
@end deffn

@c page
@node integers division floor
@subsection Rounding towards -infinity (floor)


For the examples in this section, the template operation is:

@example
N = Q * D + R
@end example

@noindent
and with floor rounding we have:

@example
N = 10
D = 3
Q = floor(N/D) = floor(10 / 3) = floor(3.33333) = 3
R = N - Q * D = 10 - 3 * 3 = +1
@end example

@noindent
for the @code{2exp} functions:

@example
N = 10
B = 3
D = 2^B = 2^3 = 8
Q = floor(N/D) = floor(10 / 8) = floor(1.25) = 1
R = N - Q * D = 10 - 1 * 8 = 10 - 8 = +2
@end example


@deffn {Generic Function} mpz-fdiv-q (@var{Q} @var{N} @var{D})
@deffnx {Method} mpz-fdiv-q ((@var{Q} mpz) (@var{N} mpz) (@var{D} mpz))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-fdiv-q Q N D)
  (mpz-get-si Q))
@result{} +3
@end lisp
@end deffn


@deffn {Generic Function} mpz-fdiv-r (@var{R} @var{N} @var{D})
@deffnx {Method} mpz-fdiv-r ((@var{R} mpz) (@var{N} mpz) (@var{D} mpz))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-fdiv-r R N D)
  (mpz-get-si R))
@result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-fdiv-qr (@var{Q} @var{R} @var{N} @var{D})
@deffnx {Method} mpz-fdiv-qr ((@var{Q} mpz) (@var{R} mpz) (@var{N} mpz) (@var{D} mpz))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-fdiv-qr Q R N D)
  (mpz-get-si Q)        @result{} +3
  (mpz-get-si R))       @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-fdiv-q-ui (@var{Q} @var{N} @var{D})
@deffnx {Method} mpz-fdiv-q-ui ((@var{Q} mpz) (@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-fdiv-q-ui Q N D)))
    (mpz-get-si Q)      @result{} +3
    absR))              @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-fdiv-r-ui (@var{R} @var{N} @var{D})
@deffnx {Method} mpz-fdiv-r-ui ((@var{R} mpz) (@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-fdiv-r-ui R N D)))
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-fdiv-qr-ui (@var{Q} @var{R} @var{N} @var{D})
@deffnx {Method} mpz-fdiv-qr-ui ((@var{Q} mpz) (@var{R} mpz) (@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-fdiv-qr-ui Q R N D)))
    (mpz-get-si Q)      @result{} +3
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-fdiv-ui (@var{N} @var{D})
@deffnx {Method} mpz-fdiv-ui ((@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((N      (mpz 10))
      (D      3))
  (mpz-fdiv-ui N D))
@result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-fdiv-q-2exp (@var{Q} @var{N} @var{B})
@deffnx {Method} mpz-fdiv-q-2exp ((@var{Q} mpz) (@var{N} mpz) (@var{B} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-fdiv-q-2exp Q N B)
  (mpz-get-si Q))
@result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-fdiv-r-2exp (@var{R} @var{N} @var{B})
@deffnx {Method} mpz-fdiv-r-2exp ((@var{R} mpz) (@var{N} mpz) (@var{B} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-fdiv-r-2exp R N B)
  (mpz-get-si R))
@result{} +2
@end lisp
@end deffn

@c page
@node integers division truncate
@subsection Rounding towards zero (truncate)


For the examples in this section, the template operation is:

@example
N = Q * D + R
@end example

@noindent
and with truncate rounding we have:

@example
N = 10
D = 3
Q = truncate(N/D) = truncate(10 / 3) = truncate(3.33333) = 3
R = N - Q * D = 10 - 3 * 3 = +1
@end example

@noindent
for the @code{2exp} functions:

@example
N = 10
B = 3
D = 2^B = 2^3 = 8
Q = truncate(N/D) = truncate(10 / 8) = truncate(1.25) = 1
R = N - Q * D = 10 - 1 * 8 = 10 - 8 = +2
@end example


@deffn {Generic Function} mpz-tdiv-q (@var{Q} @var{N} @var{D})
@deffnx {Method} mpz-tdiv-q ((@var{Q} mpz) (@var{N} mpz) (@var{D} mpz))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-tdiv-q Q N D)
  (mpz-get-si Q))
@result{} +3
@end lisp
@end deffn


@deffn {Generic Function} mpz-tdiv-r (@var{R} @var{N} @var{D})
@deffnx {Method} mpz-tdiv-r ((@var{R} mpz) (@var{N} mpz) (@var{D} mpz))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-tdiv-r R N D)
  (mpz-get-si R))
@result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-tdiv-qr (@var{Q} @var{R} @var{N} @var{D})
@deffnx {Method} mpz-tdiv-qr ((@var{Q} mpz) (@var{R} mpz) (@var{N} mpz) (@var{D} mpz))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-tdiv-qr Q R N D)
  (mpz-get-si Q)        @result{} +3
  (mpz-get-si R))       @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-tdiv-q-ui (@var{Q} @var{N} @var{D})
@deffnx {Method} mpz-tdiv-q-ui ((@var{Q} mpz) (@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-tdiv-q-ui Q N D)))
    (mpz-get-si Q)      @result{} +3
    absR))              @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-tdiv-r-ui (@var{R} @var{N} @var{D})
@deffnx {Method} mpz-tdiv-r-ui ((@var{R} mpz) (@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-tdiv-r-ui R N D)))
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-tdiv-qr-ui (@var{Q} @var{R} @var{N} @var{D})
@deffnx {Method} mpz-tdiv-qr-ui ((@var{Q} mpz) (@var{R} mpz) (@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-tdiv-qr-ui Q R N D)))
    (mpz-get-si Q)      @result{} +3
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-tdiv-ui (@var{N} @var{D})
@deffnx {Method} mpz-tdiv-ui ((@var{N} mpz) (@var{D} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((N      (mpz 10))
      (D      3))
  (mpz-tdiv-ui N D))
@result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-tdiv-q-2exp (@var{Q} @var{N} @var{B})
@deffnx {Method} mpz-tdiv-q-2exp ((@var{Q} mpz) (@var{N} mpz) (@var{B} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-tdiv-q-2exp Q N B)
  (mpz-get-si Q))
@result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-tdiv-r-2exp (@var{R} @var{N} @var{B})
@deffnx {Method} mpz-tdiv-r-2exp ((@var{R} mpz) (@var{N} mpz) (@var{B} integer))
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-tdiv-r-2exp R N B)
  (mpz-get-si R))
@result{} +2
@end lisp
@end deffn

@c page
@node integers division modulo
@subsection Modulo functions


The following functions use floor rounding, @ref{integers division floor, Rounding towards -infinity
(floor)}.


@deffn {Generic Function} mpz-mod (@var{R} @var{N} @var{D})
@deffnx {Method} mpz-mod ((@var{R} mpz) (@var{N} mpz) (@var{D} mpz))
Set @var{R} to @var{N} mod @var{D}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-mod R N D)
  (mpz-get-si R))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-mod-ui (@var{R} @var{N} @var{D})
@deffnx {Method} mpz-mod-ui ((@var{R} mpz) (@var{N} mpz) (@var{D} integer))
Set @var{R} to @var{N} mod @var{D}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (mpz-mod-ui R N D))
@result{} 1
@end lisp
@end deffn

@c page
@node integers division exact
@subsection Exact division


The following functions will return correct results only when @math{D} is an exact divisor of
@math{N}.


@deffn {Generic Function} mpz-divexact (@var{Q} @var{N} @var{D})
@deffnx {Method} mpz-divexact ((@var{Q} mpz) (@var{N} mpz) (@var{D} mpz))
Set @var{Q} to @var{N}/@var{D}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 9))
      (D      (mpz 3)))
  (mpz-divexact Q N D)
  (mpz-get-si Q))
@result{} 3
@end lisp
@end deffn


@deffn {Generic Function} mpz-divexact-ui (@var{Q} @var{N} @var{D})
@deffnx {Method} mpz-divexact-ui ((@var{Q} mpz) (@var{N} mpz) (@var{D} integer))
Set @var{Q} to @var{N}/@var{D}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 9))
      (D      3))
  (mpz-divexact-ui Q N D)
  (mpz-get-si Q))
@result{} 3
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Exact division tests


@deffn {Generic Function} mpz-divisible-p (@var{N} @var{D})
@deffnx {Method} mpz-divisible-p ((@var{N} mpz) (@var{D} mpz))
Return true if @var{N} is exactly divisible by @var{D}.

@lisp
(let ((N      (mpz 9))
      (D      (mpz 3)))
  (mpz-divisible-p N D))
@result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz-divisible-ui-p (@var{N} @var{D})
@deffnx {Method} mpz-divisible-ui-p ((@var{N} mpz) (@var{D} integer))
Return true if @var{N} is exactly divisible by @var{D}.

@lisp
(let ((N      (mpz 9))
      (D      3))
  (mpz-divisible-ui-p N D))
@result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz-divisible-2exp-p (@var{N} @var{B})
@deffnx {Method} mpz-divisible-2exp-p ((@var{N} mpz) (@var{B} integer))
Return true if @var{N} is exactly divisible by 2^@var{B}.

@lisp
(let ((N      (mpz 16))
      (B      3))
  (mpz-divisible-2exp-p N B))
@result{} t
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Congruency tests


@math{N} is congruent to @math{C} modulo @math{D} if there exists an integer @math{Q} satisfying
@math{N = C + Q * D}.


@deffn {Generic Function} mpz-congruent-p (@var{N} @var{C} @var{D})
@deffnx {Method} mpz-congruent-p ((@var{N} mpz) (@var{C} mpz) (@var{D} mpz))
Return non-zero if @var{N} is congruent to @var{C} modulo @var{D}.

@lisp
(let ((N      (mpz 7))
      (C      (mpz 1))
      (D      (mpz 3)))
  (mpz-congruent-p N C D))
@result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz-congruent-ui-p (@var{N} @var{C} @var{D})
@deffnx {Method} mpz-congruent-ui-p ((@var{N} mpz) (@var{C} integer) (@var{D} integer))
Return non-zero if @var{N} is congruent to @var{C} modulo @var{D}.

@lisp
(let ((N      (mpz 7))
      (C      1)
      (D      3))
  (mpz-congruent-ui-p N C D))
@result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz-congruent-2exp-p (@var{N} @var{C} @var{B})
@deffnx {Method} mpz-congruent-2exp-p ((@var{N} mpz) (@var{C} mpz) (@var{B} integer))
Return non-zero if @var{N} is congruent to @var{C} modulo 2^@var{B}.

@lisp
(let ((N      (mpz 17))
      (C      (mpz 1))
      (B      3))
  (mpz-congruent-2exp-p N C B))
@result{} t
@end lisp
@end deffn

@c page
@node integers exponentiation
@section Exponentiation operations


@deffn {Generic Function} mpz-powm (@var{ROP} @var{BASE} @var{EXP} @var{MOD})
@deffnx {Method} mpz-powm ((@var{ROP} mpz) (@var{BASE} mpz) (@var{EXP} mpz) (@var{MOD} mpz))
Set @var{ROP} to (@var{BASE} raised to @var{EXP}) modulo @var{MOD}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    (mpz 3))
      (mod    (mpz 2)))
  (mpz-powm rop base exp mod)
  (equal (mod (expt 5 3) 2)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz-powm-ui (@var{ROP} @var{BASE} @var{EXP} @var{MOD})
@deffnx {Method} mpz-powm-ui ((@var{ROP} mpz) (@var{BASE} mpz) (@var{EXP} integer) (@var{MOD} mpz))
Set @var{ROP} to (@var{BASE} raised to @var{EXP}) modulo @var{MOD}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    3)
      (mod    (mpz 2)))
  (mpz-powm-ui rop base exp mod)
  (equal (mod (expt 5 3) 2)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz-powm-sec (@var{ROP} @var{BASE} @var{EXP} @var{MOD})
@deffnx {Method} mpz-powm-sec ((@var{ROP} mpz) (@var{BASE} mpz) (@var{EXP} mpz) (@var{MOD} mpz))
Set @var{ROP} to (@var{BASE} raised to @var{EXP}) modulo @var{MOD}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    (mpz 3))
      (mod    (mpz 7)))
  (mpz-powm-sec rop base exp mod)
  (equal (mod (expt 5 3) 2)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz-pow-ui (@var{ROP} @var{BASE} @var{EXP})
@deffnx {Method} mpz-pow-ui ((@var{ROP} mpz) (@var{BASE} mpz) (@var{EXP} integer))
Set @var{ROP} to @var{BASE} raised to @var{EXP}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    3))
  (mpz-pow-ui rop base exp)
  (equal (expt 5 3)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz-ui-pow-ui (@var{ROP} @var{BASE} @var{EXP})
@deffnx {Method} mpz-ui-pow-ui ((@var{ROP} mpz) (@var{BASE} integer) (@var{EXP} integer))
Set @var{ROP} to @var{BASE} raised to @var{EXP}.

@lisp
(let ((rop    (mpz))
      (base   5)
      (exp    3))
  (mpz-ui-pow-ui rop base exp)
  (equal (expt 5 3)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end deffn

@c page
@node integers roots
@section Root extraction functions


@deffn {Generic Function} mpz-root (@var{ROP} @var{OP} @var{N})
@deffnx {Method} mpz-root ((@var{ROP} mpz) (@var{OP} mpz) (@var{N} integer))
Set @var{ROP} to the truncated integer part of the @var{N}th root of @var{OP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz 8))
      (N      3))
  (mpz-root rop op N)
  (mpz-get-si rop))
@result{} 2
@end lisp
@end deffn


@deffn {Generic Function} mpz-rootrem (@var{root} @var{rem} @var{U} @var{N})
@deffnx {Method} mpz-rootrem ((@var{root} mpz) (@var{rem} mpz) (@var{U} mpz) (@var{N} integer))
Set @var{ROOT} to the truncated integer part of the @var{N}th root of @var{U}.  Set @var{REM} to the
remainder, @var{U}-@var{ROOT}^@var{N}.

@lisp
;; 9 = 2^3 + 1
(let ((rop    (mpz))
      (rem    (mpz))
      (op     (mpz 9))
      (N      3))
  (mpz-rootrem rop rem op N)
  (mpz-get-si rop)      @result{} 2
  (mpz-get-si rem))     @result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-sqrt (@var{ROP} @var{OP})
@deffnx {Method} mpz-sqrt ((@var{ROP} mpz) (@var{OP} mpz))
Set @var{ROP} to the truncated integer part of the square root of @var{OP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz 16)))
  (mpz-sqrt rop op)
  (mpz-get-si rop))
@result{} 4
@end lisp
@end deffn


@deffn {Generic Function} mpz-sqrtrem (@vari{rop} @varii{rop} @var{OP})
@deffnx {Method} mpz-sqrtrem ((@vari{rop} mpz) (@var{ROP} mpz) (@var{OP} mpz))
Set @vari{ROP} to the truncated integer part of the square root of @var{OP}.  Set @varii{ROP} to the
remainder @var{OP}-@vari{ROP}*@vari{ROP}.

@lisp
;; 17 = 4^2 + 1
(let ((rop    (mpz))
      (rem    (mpz))
      (op     (mpz 17)))
  (mpz-sqrtrem rop rem op)
  (mpz-get-si rop)      @result{} 4
  (mpz-get-si rem))     @result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-perfect-power-p (@var{OP})
@deffnx {Method} mpz-perfect-power-p ((@var{OP} mpz))
Return true if @var{OP} is a perfect power; otherwise return false.

@lisp
(mpz-perfect-power-p (mpz 8))           @result{} t
(mpz-perfect-power-p (mpz 7))           @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpz-perfect-square-p (@var{OP})
@deffnx {Method} mpz-perfect-square-p ((@var{OP} mpz))
Return true if @var{OP} is a perfect square; otherwise return false.

@lisp
(mpz-perfect-square-p (mpz 16))         @result{} t
(mpz-perfect-square-p (mpz 7))          @result{} nil
@end lisp
@end deffn

@c page
@node integers comparison
@section Commparison functions


@deffn {Generic Function} mpz-cmp (@vari{OP} @varii{OP})
@deffnx {Method} mpz-cmp ((@vari{OP} mpz) (@varii{OP} mpz))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp (mpz 1) (mpz 2))       @result{} -1
(mpz-cmp (mpz 0) (mpz 0))       @result{} 0
(mpz-cmp (mpz 2) (mpz 1))       @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmp-d (@vari{OP} @varii{OP})
@deffnx {Method} mpz-cmp-d ((@vari{OP} mpz) (@varii{OP} float))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp-d (mpz 1) 2.0))        @result{} -1
(mpz-cmp-d (mpz 0) 0.0))        @result{} 0
(mpz-cmp-d (mpz 2) 1.0))        @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmp-si (@vari{OP} @varii{OP})
@deffnx {Method} mpz-cmp-si ((@vari{OP} mpz) (@varii{OP} integer))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp-si (mpz -2) -1))       @result{} -1
(mpz-cmp-si (mpz  0)  0))       @result{} 0
(mpz-cmp-si (mpz -1) -2))       @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmp-ui (@vari{OP} @varii{OP})
@deffnx {Method} mpz-cmp-ui ((@vari{OP} mpz) (@varii{OP} integer))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp-ui (mpz 1) 2))         @result{} -1
(mpz-cmp-ui (mpz 0) 0))         @result{} 0
(mpz-cmp-ui (mpz 2) 1))         @result{} +1
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-cmpabs (@vari{OP} @varii{OP})
@deffnx {Method} mpz-cmpabs ((@vari{OP} mpz) (@varii{OP} mpz))
Compare the absolute values of OP1 and OP2.

@lisp
(mpz-cmpabs (mpz 1) (mpz -2))   @result{} -1
(mpz-cmpabs (mpz 0) (mpz  0))   @result{} 0
(mpz-cmpabs (mpz 2) (mpz  1))   @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmpabs-d (@vari{OP} @varii{OP})
@deffnx {Method} mpz-cmpabs-d ((@vari{OP} mpz) (@varii{OP} float))
Compare the absolute values of OP1 and OP2.

@lisp
(mpz-cmpabs-d (mpz 1) -2.0)     @result{} -1
(mpz-cmpabs-d (mpz 0)  0.0)     @result{} 0
(mpz-cmpabs-d (mpz 2)  1.0)     @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmpabs-ui (@vari{OP} @varii{OP})
@deffnx {Method} mpz-cmpabs-ui ((@vari{OP} mpz) (@varii{OP} integer))
Compare the absolute values of OP1 and OP2.

@lisp
(mpz-cmpabs-ui (mpz  1) 2)      @result{} -1
(mpz-cmpabs-ui (mpz  0) 0)      @result{} 0
(mpz-cmpabs-ui (mpz -2) 1)      @result{} +1
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-sgn (@var{OP})
@deffnx {Method} mpz-sgn ((@var{OP} mpz))
Return an integer representing the sign of the operand.

@lisp
(mpz-sgn (mpz +1))      @result{} +1
(mpz-sgn (mpz  0))      @result{} 0
(mpz-sgn (mpz -1))      @result{} -1
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-zero-p (@var{OP})
@deffnx {Method} mpz-zero-p ((@var{OP} mpz))
Return true if @var{OP} is zero; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-non-zero-p (@var{OP})
@deffnx {Method} mpz-non-zero-p ((@var{OP} mpz))
Return true if @var{OP} is non-zero; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-positive-p (@var{OP})
@deffnx {Method} mpz-positive-p ((@var{OP} mpz))
Return true if @var{OP} is strictly positive; otherwise return false.
@end deffn

@deffn {Generic Function} mpz-negative-p (@var{OP})
@deffnx {Method} mpz-negative-p ((@var{OP} mpz))
Return true if @var{OP} is strictly negative; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-non-positive-p (@var{OP})
@deffnx {Method} mpz-non-positive-p ((@var{OP} mpz))
Return true if @var{OP} is non-positive; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-non-negative-p (@var{OP})
@deffnx {Method} mpz-non-negative-p ((@var{OP} mpz))
Return true if @var{OP} is non-negative; otherwise return false.
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz< (@var{OP} &rest @var{OPS})
@deffnx {Method} mpz< ((@vari{OP} mpz) (@varii{OP} mpz))
Return true if each argument is strictly less than the following argument; otherwise return false.

@lisp
(mpz< (mpz 1) (mpz 2))          @result{} t
(mpz< (mpz 1) (mpz 1))          @result{} nil
(mpz< (mpz 2) (mpz 1))          @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpz> (@var{OP} &rest @var{OPS})
@deffnx {Method} mpz> ((@vari{OP} mpz) (@varii{OP} mpz))
Return true if each argument is strictly greater than the following argument; otherwise return
false.

@lisp
(mpz> (mpz 1) (mpz 2))          @result{} nil
(mpz> (mpz 1) (mpz 1))          @result{} nil
(mpz> (mpz 2) (mpz 1))          @result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz<= (@var{OP} &rest @var{OPS})
@deffnx {Method} mpz<= ((@vari{OP} mpz) (@varii{OP} mpz))
Return true if each argument is strictly less than, or equal to, the following argument; otherwise
return false.

@lisp
(mpz<= (mpz 1) (mpz 2))         @result{} t
(mpz<= (mpz 1) (mpz 1))         @result{} t
(mpz<= (mpz 2) (mpz 1))         @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpz>= (@var{OP} &rest @var{OPS})
@deffnx {Method} mpz>= ((@vari{OP} mpz) (@varii{OP} mpz))
Return true if each argument is greater than, or equal to, the following argument; otherwise return
false.

@lisp
(mpz>= (mpz 1) (mpz 2))         @result{} nil
(mpz>= (mpz 1) (mpz 1))         @result{} t
(mpz>= (mpz 2) (mpz 1))         @result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpz= (@var{OP} &rest @var{OPS})
@deffnx {Method} mpz= ((@vari{OP} mpz) (@varii{OP} mpz))
Return true if each argument is equal to the following argument; otherwise return false.

@lisp
(mpz= (mpz 1) (mpz 2))          @result{} nil
(mpz= (mpz 1) (mpz 1))          @result{} t
(mpz= (mpz 2) (mpz 1))          @result{} nil
@end lisp
@end deffn

@c page
@node integers theoretic
@section Number theoretic functions


@deffn {Generic Function} mpz-probab-prime-p (@var{N} @var{REPS})
@deffnx {Method} mpz-probab-prime-p ((@var{N} mpz) (@var{REPS} integer))
Determine whether @var{N} is prime.

@lisp
(mpz-probab-prime-p (mpz 3) 2)
@result{} 2
@end lisp
@end deffn


@deffn {Generic Function} mpz-nextprime (@var{ROP} @var{OP})
@deffnx {Method} mpz-nextprime ((@var{ROP} mpz) (@var{OP} mpz))
Set @var{ROP} to the next prime greater than @var{OP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz 5)))
  (mpz-nextprime rop op)
  (mpz-get-si rop))
@result{} 7a
@end lisp
@end deffn


@deffn {Generic Function} mpz-gcd (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-gcd ((@var{ROP} mpz) (@var{OP1} mpz) (@var{OP2} mpz))
Set @var{ROP} to the greatest common divisor of @var{OP1} and @var{OP2}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz 10))
      (op2    (mpz 12)))
  (mpz-gcd rop op1 op2)
  (mpz-get-si rop))
@result{} 2
@end lisp
@end deffn


@deffn {Generic Function} mpz-gcd-ui (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-gcd-ui ((@var{ROP} mpz) (@var{OP1} mpz) (@var{OP2} integer))
Set @var{ROP} to the greatest common divisor of @var{OP1} and @var{OP2}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz 10))
      (op2    12))
  (let ((rop1 (mpz-gcd-ui rop op1 op2)))
    (mpz-get-si rop)    @result{} 2
    rop1))              @result{} 2
@end lisp
@end deffn


@deffn {Generic Function} mpz-gcdext (@var{G} @var{S} @var{T} @var{A} @var{B})
@deffnx {Method} mpz-gcdext ((G mpz) (S mpz) (T mpz) (A mpz) (B mpz))
Set @var{G} to the greatest common divisor of @var{A} and @var{B}, and in addition set @var{S} and
@var{T} to coefficients satisfying @var{A}*@var{S} + @var{B}*@var{T} = @var{G}.

@lisp
;; A * S + B * T = G -> 110 * 3 + 82 * (-4) = 2
(let ((G      (mpz))
      (S      (mpz))
      (T      (mpz))
      (A      (mpz 110))
      (B      (mpz 82)))
  (mpz-gcdext G S T A B)
  (mpz-get-si G)        @result{} +2
  (mpz-get-si S)        @result{} +3
  (mpz-get-si T))       @result{} -4
@end lisp
@end deffn


@deffn {Generic Function} mpz-lcm (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-@var{LCM} ((rop mpz) (@var{OP1} mpz) (@var{OP2} mpz))
Set @var{ROP} to the least common multiple of @var{OP1} and @var{OP2}.

@lisp
;;(* 2 7 5) => 70
(let ((rop    (mpz))
      (op1    (mpz (* 2 5)))
      (op2    (mpz (* 2 7))))
  (mpz-lcm rop op1 op2)
  (mpz-get-si rop))
@result{} 70
@end lisp
@end deffn


@deffn {Generic Function} mpz-lcm-ui (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-lcm-ui ((@var{ROP} mpz) (@var{OP1} mpz) (@var{OP2} integer))
Set @var{ROP} to the least common multiple of @var{OP1} and @var{OP2}.

@lisp
;;(* 2 7 5) => 70
(let ((rop    (mpz))
      (op1    (mpz (* 2 5)))
      (op2    (* 2 7)))
  (mpz-lcm-ui rop op1 op2)
  (mpz-get-si rop))
@result{} 70
@end lisp
@end deffn


@deffn {Generic Function} mpz-invert (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-invert ((@var{ROP} mpz) (@var{OP1} mpz) (@var{OP2} mpz))
Compute the inverse of @var{OP1} modulo @var{OP2} and put the result in @var{ROP}.  See:

@center @url{https://en.wikipedia.org/wiki/Modular_multiplicative_inverse}

@lisp
;;OP2 divides (evenly) the quantity ROP * OP1 - 1
;;
;; ROP * OP1 = X * OP2 + 1
;; 4 * 3 = 1 * 11 + 1
;;
(let ((rop    (mpz))
      (op1    (mpz 3))
      (op2    (mpz 11)))
  (let ((rv (mpz-invert rop op1 op2)))
    rv                  @result{} t
    (mpz-get-si rop)))  @result{} 4
@end lisp
@end deffn


@deffn {Generic Function} mpz-jacobi (@var{A} @var{B})
@deffnx {Method} mpz-jacobi ((@var{A} mpz) (@var{B} mpz))
Calculate the Jacobi symbol (@var{A}/@var{B}).  This is defined only for @var{B} odd.

@lisp
(let ((A      (mpz 11))
      (B      (mpz 9)))
  (mpz-jacobi A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-legendre (@var{A} @var{B})
@deffnx {Method} mpz-legendre ((@var{A} mpz) (@var{B} mpz))
Calculate the Legendre symbol (@var{A}/@var{P}).

@lisp
(let ((A      (mpz 20))
      (P      (mpz 11)))
  (mpz-legendre A P))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-kronecker (@var{A} @var{B})
@deffnx {Method} mpz-kronecker ((@var{A} mpz) (@var{B} mpz))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(@var{2}/A)
when a odd, or (@var{A}/2)=0 @var{WHEN} a even.

@lisp
(let ((A      (mpz 15))
      (B      (mpz 4)))
  (mpz-kronecker A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-kronecker-si (@var{A} @var{B})
@deffnx {Method} mpz-kronecker-si ((@var{A} mpz) (@var{B} integer))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(2/@var{A})
when @var{A} odd, or (@var{A}/2)=0 when a even.

@lisp
(let ((A      (mpz 15))
      (B      4))
  (mpz-kronecker-si A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-kronecker-ui (@var{A} @var{B})
@deffnx {Method} mpz-kronecker-ui ((@var{A} mpz) (@var{B} integer))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(2/@var{A})
when @var{A} odd, or (@var{A}/2)=0 when a even.

@lisp
(let ((A      (mpz 15))
      (B      4))
  (mpz-kronecker-ui A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-si-kronecker (A B)
@deffnx {Method} mpz-si-kronecker ((A integer) (B mpz))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(2/@var{A})
when @var{A} odd, or (@var{A}/2)=0 when a even.

@lisp
(let ((A      15)
      (B      (mpz 4)))
  (mpz-si-kronecker A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-ui-kronecker (A B)
@deffnx {Method} mpz-ui-kronecker ((A integer) (B mpz))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(2/@var{A})
when @var{A} odd, or (@var{A}/2)=0 when a even.

@lisp
(let ((A      15)
      (B      (mpz 4)))
  (mpz-ui-kronecker A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-remove (@var{ROP} @var{OP} @var{F})
@deffnx {Method} mpz-remove ((@var{ROP} mpz) (@var{OP} mpz) (@var{F} mpz))
Remove all occurrences of the factor @var{F} from @var{OP} and store the result in @var{ROP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz 45))
      (F      (mpz 3)))
  (let ((rv (mpz-remove rop op F)))
    rv                  @result{} 2
    (mpz-get-si rop)))  @result{} 5
@end lisp
@end deffn


@deffn {Generic Function} mpz-fac-ui (@var{ROP} @var{N})
@deffnx {Method} mpz-fac-ui ((@var{ROP} mpz) (@var{N} integer))
Set @var{ROP} to the factorial of @var{N}.

@lisp
;; (* 4 3 2 1) => 24
(let ((rop    (mpz))
      (N      4))
  (mpz-fac-ui rop N)
  (mpz-get-si rop))
@result{} 24
@end lisp
@end deffn


@deffn {Generic Function} mpz-2fac-ui (@var{ROP} @var{N})
@deffnx {Method} mpz-2fac-ui ((@var{ROP} mpz) (@var{N} integer))
Set @var{ROP} to the double factorial of @var{N}: @var{N}!!.  See:

@center @url{https://en.wikipedia.org/wiki/Factorial#Multifactorials}

@lisp
;;from the full factorial select the first number every 2:
;;
;; (* 9 8 7 6 5 4 3 2 1) -> (* 9 7 5 3 1) => 945
;;    ^   ^   ^   ^   ^
;;
(let ((rop    (mpz))
      (N      9))
  (mpz-2fac-ui rop N)
  (mpz-get-si rop))
@result{} 945
@end lisp
@end deffn


@deffn {Generic Function} mpz-mfac-uiui (@var{ROP} @var{N} @var{M})
@deffnx {Method} mpz-mfac-uiui ((@var{ROP} mpz) (@var{N} integer) (@var{M} integer))
Set @var{ROP} to the @var{M}--multi--factorial of @var{N}: @var{N}!^(@var{M}).  See:

@center @url{https://en.wikipedia.org/wiki/Factorial#Multifactorials}

@lisp
;;from the full factorial select the first number every 4:
;;
;;(* 10 9 8 7 6 5 4 3 2 1) -> (* 10 6 2) => 120
;;   ^        ^       ^
(let ((rop    (mpz))
      (N      10)
      (M      4))
  (mpz-mfac-uiui rop N M)
  (mpz-get-si rop))
@result{} 120
@end lisp
@end deffn


@deffn {Generic Function} mpz-primorial-ui (@var{ROP} @var{N})
@deffnx {Method} mpz-primorial-ui ((@var{ROP} mpz) (@var{N} integer))
Set @var{ROP} to the primorial of @var{N}: the product of all positive prime numbers <=@var{N}.

@lisp
;; (* 7 5 3 2 1) => 210
(let ((rop    (mpz))
      (op     7))
  (mpz-primorial-ui rop op)
  (mpz-get-si rop))
@result{} 210
@end lisp
@end deffn


@deffn {Generic Function} mpz-bin-ui (@var{ROP} @var{N} @var{K})
@deffnx {Method} mpz-bin-ui ((@var{ROP} mpz) (@var{N} mpz) (@var{K} integer))
Compute the binomial coefficient @var{N} over @var{K} and store the result in @var{ROP}.

@lisp
(let ((rop    (mpz))
      (N      (mpz 4))
      (K      2))
  (mpz-bin-ui rop N K)
  (mpz-get-si rop))
@result{} 6
@end lisp
@end deffn


@deffn {Generic Function} mpz-bin-uiui (@var{ROP} @var{N} @var{K})
@deffnx {Method} mpz-bin-uiui ((@var{ROP} mpz) (@var{N} integer) (@var{K} integer))
Compute the binomial coefficient @var{N} over @var{K} and store the result in @var{ROP}.

@lisp
(let ((rop    (mpz))
      (N      4)
      (K      2))
  (mpz-bin-uiui rop N K)
  (mpz-get-si rop))
@result{} 6
@end lisp
@end deffn


@deffn {Generic Function} mpz-fib-ui (@var{FN} @var{N})
@deffnx {Method} mpz-fib-ui ((@var{FN} mpz) (@var{N} integer))
Set @var{FN} to to F[@var{N}]: the @var{N}'th Fibonacci number.

@lisp
(let ((FN     (mpz))
      (N      20))
  (mpz-fib-ui FN N)
  (mpz-get-si FN))
@result{} 6765
@end lisp
@end deffn


@deffn {Generic Function} mpz-fib2-ui (FN FNSUB1 N)
@deffnx {Method} mpz-fib2-ui ((FN mpz) (FNSUB1 mpz) (N integer))
Set @var{FN} to to F[@var{N}]: the @var{N}'th Fibonacci number.  Set @var{FNSUB1} to to
F[@var{N}-1].

@lisp
(let ((FN     (mpz))
      (FNSUB1 (mpz))
      (N      20))
  (mpz-fib2-ui FN FNSUB1 N)
  (mpz-get-si FN)               @result{} 6765
  (mpz-get-si FNSUB1))          @result{} 4181
@end lisp
@end deffn


@deffn {Generic Function} mpz-lucnum-ui (@var{LN} @var{N})
@deffnx {Method} mpz-lucnum-ui ((@var{LN} mpz) (@var{N} mpz))
Set @var{LN} to to L[@var{N}]: the @var{N}'th Lucas number.

@lisp
(let ((LN     (mpz))
      (N      9))
  (mpz-lucnum-ui LN N)
  (mpz-get-si LN))
@result{} 76
@end lisp
@end deffn


@deffn {Generic Function} mpz-lucnum2-ui (@var{LN} @var{LNSUB1} @var{N})
@deffnx {Method} mpz-lucnum2-ui ((@var{LN} mpz) (@var{LNSUB1} mpz) (@var{N} integer))
Set @var{LN} to to L[@var{N}]: the @var{N}'th Lucas number.  Set @var{LNSUB1} to to L[@var{N}-1].

@lisp
(let ((LN     (mpz))
      (LNSUB1 (mpz))
      (N      9))
  (mpz-lucnum2-ui LN LNSUB1 N)
  (mpz-get-si LN)       @result{} 76
  (mpz-get-si LNSUB1))  @result{} 47
@end lisp
@end deffn

@c page
@node integers bitlogic
@section Logical and bit manipulation functions


@c void mpz_and (mpz_t @var{ROP}, const mpz_t @vari{OP}, const mpz_t @varii{OP})
@deffn {Generic Function} mpz-and (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-and ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Set @var{ROP} to @vari{OP} bitwise--and @varii{OP}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz #b1010101))
      (op2    (mpz #b1101011)))
  (mpz-and rop op1 op2)
  (mpz-get-si rop))
@result{} #b1000001
@end lisp
@end deffn


@c void mpz_ior (mpz_t @var{ROP}, const mpz_t @vari{OP}, const mpz_t @varii{OP})
@deffn {Generic Function} mpz-ior (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-ior ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Set @var{ROP} to @vari{OP} bitwise inclusive--or @varii{OP}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz #b1010101))
      (op2    (mpz #b1110101)))
  (mpz-ior rop op1 op2)
  (mpz-get-si rop))
@result{} #b1110101
@end lisp
@end deffn


@c void mpz_xor (mpz_t @var{ROP}, const mpz_t @vari{OP}, const mpz_t @varii{OP})
@deffn {Generic Function} mpz-xor (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-xor ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Set @var{ROP} to @vari{OP} bitwise exclusive--or @varii{OP}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz #b1110101))
      (op2    (mpz #b1011101)))
  (mpz-xor rop op1 op2)
  (mpz-get-si rop))
@result{} #b0101000
@end lisp
@end deffn


@c void mpz_com (mpz_t @var{ROP}, const mpz_t @var{OP})
@deffn {Generic Function} mpz-com (@var{ROP} @var{OP})
@deffnx {Method} mpz-com ((@var{ROP} mpz) (@var{OP} mpz))
Set @var{ROP} to the one's complement of @var{OP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz #b10)))
  (mpz-com rop op)
  (mpz-get-si rop))
@result{} -3
@end lisp
@end deffn


@c mp_bitcnt_t mpz_popcount (const mpz_t @var{OP})
@deffn {Generic Function} mpz-popcount (op)
@deffnx {Method} mpz-popcount ((@var{OP} mpz))
Return the population count of @var{OP}.

@lisp
(mpz-popcount (mpz #b1010101))
@result{} 4
@end lisp
@end deffn


@c mp_bitcnt_t mpz_hamdist (const mpz_t @vari{OP}, const mpz_t @varii{OP})
@deffn {Generic Function} mpz-hamdist (@vari{OP} @varii{OP})
@deffnx {Method} mpz-hamdist ((@vari{OP} mpz) (@varii{OP} mpz))
Return the hamming distance between the two operands.

@lisp
(let ((op1    (mpz 63))
      (op2    (mpz 70)))
  (mpz-hamdist op1 op2))
@result{} 5
@end lisp
@end deffn


@c mp_bitcnt_t mpz_scan0 (const mpz_t @var{OP}, mp_bitcnt_t STARTING_BIT)
@deffn {Generic Function} mpz-scan0 (op @var{STARTING-BIT})
@deffnx {Method} mpz-scan0 ((@var{OP} mpz) (@var{STARTING-BIT} integer))
Scan @var{OP} for the first 0 bit.

@lisp
(let ((op             (mpz #b1000110))
      (starting-bit   1))
  (mpz-scan0 op starting-bit))
@result{} 3

(let ((op             (mpz #b1011111))
      (starting-bit   2))
  (mpz-scan0 op starting-bit))
@result{} 5
@end lisp
@end deffn


@c mp_bitcnt_t mpz_scan1 (const mpz_t @var{OP}, mp_bitcnt_t STARTING_BIT)
@deffn {Generic Function} mpz-scan1 (op @var{STARTING-BIT})
@deffnx {Method} mpz-scan1 ((@var{OP} mpz) (@var{STARTING-BIT} integer))
Scan @var{OP} for the first 1 bit.

@lisp
(let ((op             (mpz #b1000110))
      (starting-bit   3))
  (mpz-scan1 op starting-bit))
@result{} 6

(let ((op             (mpz #b010000))
      (starting-bit   2))
  (mpz-scan1 op starting-bit))
@result{} 4
@end lisp
@end deffn


@c void mpz_setbit (mpz_t @var{ROP}, mp_bitcnt_t BIT_INDEX)
@deffn {Generic Function} mpz-setbit (@var{ROP} @var{BIT-INDEX})
@deffnx {Method} mpz-setbit ((@var{ROP} mpz) (@var{BIT-INDEX} integer))
Set bit BIT_INDEX in @var{ROP}.

@lisp
(let ((rop            (mpz))
      (bit-index      3))
  (mpz-setbit rop bit-index)
  (mpz-get-si rop))
@result{} 8
@end lisp
@end deffn


@c void mpz_clrbit (mpz_t @var{ROP}, mp_bitcnt_t BIT_INDEX)
@deffn {Generic Function} mpz-clrbit (@var{ROP} @var{BIT-INDEX})
@deffnx {Method} mpz-clrbit ((@var{ROP} mpz) (@var{BIT-INDEX} integer))
Clear bit BIT_INDEX in @var{ROP}.

@lisp
(let ((rop            (mpz #b00100))
      (bit-index      2))
  (mpz-clrbit rop bit-index)
  (mpz-get-si rop))
@result{} 0
@end lisp
@end deffn


@c void mpz_combit (mpz_t @var{ROP}, mp_bitcnt_t BIT_INDEX)
@deffn {Generic Function} mpz-combit (@var{ROP} @var{BIT-INDEX})
@deffnx {Method} mpz-combit ((@var{ROP} mpz) (@var{BIT-INDEX} integer))
Complement bit BIT_INDEX in @var{ROP}.

@lisp
(let ((rop            (mpz #b00100))
      (bit-index      2))
  (mpz-combit rop bit-index)
  (mpz-get-si rop))
@result{} 0
@end lisp
@end deffn


@c int mpz_tstbit (const mpz_t @var{OP}, mp_bitcnt_t BIT_INDEX)
@deffn {Generic Function} mpz-tstbit (op @var{BIT-INDEX})
@deffnx {Method} mpz-tstbit ((@var{OP} mpz) (@var{BIT-INDEX} integer))
Test bit BIT_INDEX in @var{OP} and return 0 or 1 accordingly.

@lisp
(let ((op             (mpz #b01000))
      (bit-index      3))
  (mpz-tstbit op bit-index))
@result{} t

(let ((op             (mpz #b10111))
      (bit-index      3))
  (mpz-tstbit op bit-index))
@result{} nil
@end lisp
@end deffn

@c page
@node integers random
@section Random number functions


@c void mpz_urandomb (mpz_t ROP, gmp_randstate_t STATE, mp_bitcnt_t N)
@deffn {Generic Function} mpz-urandomb (@var{ROP} @var{STATE} @var{N})
@deffnx {Method} mpz-urandomb ((@var{ROP} mpz) (@var{STATE} gmp-randstate) (@var{N} integer))
Generate a uniformly distributed random integer in the range 0 to 2^@var{N}-1, inclusive.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (N              3))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-urandomb rop state N)
  (let ((num (mpz-get-ui rop)))
    (and (>= num 0)
         (<  num (expt 2 N)))))
@result{} t
@end lisp
@end deffn


@c void mpz_urandomm (mpz_t ROP, gmp_randstate_t STATE, const mpz_t N)
@deffn {Generic Function} mpz-urandomm (@var{ROP} @var{STATE} @var{N})
@deffnx {Method} mpz-urandomm ((@var{ROP} mpz) (@var{STATE} gmp-randstate) (@var{N} mpz))
Generate a uniform random integer in the range 0 to @var{N}-1, inclusive.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (N              (mpz 3)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-urandomm rop state N)
  (let ((num (mpz-get-ui rop)))
    (and (>= num 0)
         (<  num (mpz-get-ui N)))))
@result{} t
@end lisp
@end deffn


@c void mpz_rrandomb (mpz_t ROP, gmp_randstate_t STATE, mp_bitcnt_t N)
@deffn {Generic Function} mpz-rrandomb (@var{ROP} @var{STATE} @var{N})
@deffnx {Method} mpz-rrandomb ((@var{ROP} mpz) (@var{STATE} gmp-randstate) (@var{N} integer))
Generate a random integer with long strings of zeros and ones in the binary representation.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (N              3))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-rrandomb rop state N)
  (let ((num (mpz-get-ui rop)))
    (and (>= num 0)
         (<  num (expt 2 N)))))
@result{} t
@end lisp
@end deffn


@c void mpz_random (mpz_t ROP, mp_size_t MAX_SIZE)
@deffn {Generic Function} mpz-random (@var{ROP} @var{MAX-SIZE})
@deffnx {Method} mpz-random ((@var{ROP} mpz) (@var{MAX-SIZE} integer))
Generate a random integer of at most @var{MAX-SIZE} limbs.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (max-size       1))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-random rop max-size)
  rop)
@result{} <some number>
@end lisp
@end deffn


@c void mpz_random2 (mpz_t ROP, mp_size_t MAX_SIZE)
@deffn {Generic Function} mpz-random2 (@var{ROP} @var{MAX-SIZE})
@deffnx {Method} mpz-random2 ((@var{ROP} mpz) (@var{MAX-SIZE} integer))
Generate a random integer of at most @var{MAX-SIZE} limbs, with long strings of zeros and ones in
the binary representation.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (max-size       1))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-random2 rop max-size)
  rop)
@result{} <some number>
@end lisp
@end deffn

@c page
@node integers miscellaneous
@section Miscellaneous functions


@deffn {Generic Function} mpz-fits-ulong-p (@var{OP})
@deffnx {Method} mpz-fits-ulong-p ((@var{OP} mpz))
Return true if the operand fits an @code{unsigned long int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-slong-p (@var{OP})
@deffnx {Method} mpz-fits-slong-p ((@var{OP} mpz))
Return true if the operand fits a `@code{igned long int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-uint-p (@var{OP})
@deffnx {Method} mpz-fits-uint-p ((@var{OP} mpz))
Return true if the operand fits an @code{unsigned int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-sint-p (@var{OP})
@deffnx {Method} mpz-fits-sint-p ((@var{OP} mpz))
Return true if the operand fits n `@code{igned int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-ushort-p (@var{OP})
@deffnx {Method} mpz-fits-ushort-p ((@var{OP} mpz))
Return true if the operand fits an @code{unsigned short int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-sshort-p (@var{OP})
@deffnx {Method} mpz-fits-sshort-p ((@var{OP} mpz))
Return true if the operand fits a @code{signed short int}; otherwise return false.
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-odd-p (@var{OP})
@deffnx {Method} mpz-odd-p ((@var{OP} mpz))
Return true if the operand is odd; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-even-p (@var{OP})
@deffnx {Method} mpz-even-p ((@var{OP} mpz))
Return true if the operand is even; otherwise return false.
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-sizeinbase (@var{OP} @var{BASE})
@deffnx {Method} mpz-sizeinbase ((@var{OP} mpz) (@var{BASE} integer))
Return the size of @var{OP} measured in number of digits in the given @var{BASE}.

The argument @var{BASE} can vary from @math{2} to @math{62}.
@end deffn

@c page
@node rationals
@chapter Rational number objects and operations


@deftp {Object Type} mpq
Type of structures representing a multiple precision rational numbers.  It is a wrapper for the C
language type @objtype{mpq_t}.  These objects, and their internal representation, are correctly
garbage collected.
@end deftp


@menu
* rationals allocation::        Allocating rational numbers.
* rationals predicates::        Rational number predicates.
* rationals assignment::        Assigning values to rational
                                number objects.
* rationals conversion::        Converting rational numbers to
                                other objects.
* rationals arithmetic::        Arithmetic operations.
* rationals comparison::        Comparison functions.
@end menu

@c page
@node rationals allocation
@section Allocating rational numbers


@defun mpq &optional @var{INIT} @var{DENOMINATOR-INIT}
Build and return a new @objtype{mpq} object instance.  When called with no arguments: the object is
uninitialised.

When the @var{INIT} argument is provided and the argument @var{DENOMINATOR-INIT} is not: @var{INIT}
must be an initialisation value for the @objtype{mpq} object.  It can be: a floating--point number;
an @objtype{mpz} object; an @objtype{mpq} object; an @objtype{mpf} object.

@lisp
(let ((op (mpq 1.2)))
  (mpq-get-str 10 op))
@result{} "5404319552844595/4503599627370496"
@end lisp

When both the @var{INIT} and @var{DENOMINATOR-INIT} arguments are provided: they must be
initialisation values for the numerator and the denominator of the new rational number.  They can
be: exact integer numbers.

@lisp
(let ((op (mpq 3 4)))
  (mpq-get-str 10 op))
@result{} "3/4"
@end lisp

When both the @var{INIT} and @var{DENOMINATOR-INIT} arguments are missing: the returned object is
set to zero.

@lisp
(let ((op (mpq)))
  (mpq-get-str 10 op))
@result{} "0"
@end lisp
@end defun

@c page
@node rationals predicates
@section Rational number predicates


@defun mpq-p @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{mpq}; otherwise return @false{}.

@lisp
(mpq-p (mpq))   @result{} t
(mpq-p 123)     @result{} nil
@end lisp
@end defun

@c page
@node rationals assignment
@section Assigning values to rational number objects


@c void mpq_canonicalize (mpq_t OP)
@deffn {Generic Function} mpq-canonicalize (@var{OP})
@deffnx {Method} mpq-canonicalize ((@var{OP} mpq))
Remove any factors that are common to the numerator and denominator of OP, and make the denominator
positive.
@end deffn


@deffn {Generic Function} mpq-set (@var{ROP} @var{OP})
@deffnx {Method} mpq-set ((@var{ROP} mpq) (@var{OP} mpq))
Assign the value of @var{OP} to @var{ROP}; both the operands must be of type @objtype{mpq}.

@lisp
(let ((rop (mpq))
      (op  (mpq)))
  (mpq-set-si rop 3 4)
  (mpq-set    op rop)
  (mpq-get-str 10 op))
@result{} "3/4"
@end lisp
@end deffn


@deffn {Generic Function} mpq-set-si (@var{ROP} @var{numerator-integer} @var{denominator-integer})
@deffnx {Method} mpq-set-si ((@var{ROP} mpq) (@var{numerator-integer} integer) (@var{denominator-integer} integer))
Assign the value of the signed exact integer numbers @var{numerator-integer} and
@var{denominator-integer} to the @objtype{mpq} object @var{ROP}.

@lisp
(let ((rop (mpq)))
  (mpq-set-si rop 3 4)
  (mpq-get-str 10 rop))
@result{} "3/4"
@end lisp
@end deffn


@deffn {Generic Function} mpq-set-ui (@var{ROP} @var{numerator-integer} @var{denominator-integer})
@deffnx {Method} mpq-set-ui ((@var{ROP} mpq) (@var{numerator-integer} integer) (@var{denominator-integer} integer))
Assign the value of the unsigned exact integer numbers @var{numerator-integer} and
@var{denominator-integer} to the @objtype{mpq} object @var{ROP}.

@lisp
(let ((rop (mpq)))
  (mpq-set-ui rop 3 4)
  (mpq-get-str 10 rop))
@result{} "3/4"
@end lisp
@end deffn


@deffn {Generic Function} mpq-set-d (@var{ROP} @var{flo})
@deffnx {Method} mpq-set-d ((@var{ROP} mpq) (@var{flo} float))
Assign the value of a floating--point object to an @objtype{mpq} object.

@lisp
(let ((rop (mpq)))
  (mpq-set-d rop 1.2)
  (mpq-get-str 10 rop))
@result{} "5404319552844595/4503599627370496"
@end lisp
@end deffn


@deffn {Generic Function} mpq-set-z (@var{ROP} @var{OP})
@deffnx {Method} mpq-set-z ((@var{ROP} mpq) (@var{OP} mpz))
Assign the value of an @objtype{mpz} object to an @objtype{mpq} object.

@lisp
(let ((rop (mpq))
      (op  (mpz 123)))
  (mpq-set-z rop op)
  (mpq-get-str 10 rop))
@result{} "123"
@end lisp
@end deffn


@deffn {Generic Function} mpq-set-f (@var{ROP} @var{OP})
@deffnx {Method} mpq-set-f ((@var{ROP} mpq) (@var{OP} mpf))
Assign the value of an @objtype{mpf} object to an @objtype{mpq} object.

@lisp
(let ((rop (mpq))
      (op  (mpf 1.2)))
  (mpq-set-f rop op)
  (mpq-get-str 10 rop))
@result{} "5404319552844595/4503599627370496"
@end lisp
@end deffn


@deffn {Generic Function} mpq-set-str (@var{ROP} @var{STR} @var{BASE})
@deffnx {Method} mpq-set-str ((@var{ROP} mpq) (@var{STR} string) (@var{BASE} integer))
Assign the value of a string object to an @objtype{mpq} object.  The argument @var{BASE} must be an
exact integer representing the base of the numeric string representation: @math{0} or a value
between @math{2} and @math{62}.

@lisp
(let ((rop (mpq)))
  (mpq-set-str rop "3/4" 10)
  (mpq-get-str 10 rop))
@end lisp
@end deffn


@deffn {Generic Function} mpq-swap (@vari{OP} @varii{OP})
@deffnx {Method} mpq-swap ((@vari{OP} mpq) (@varii{OP} mpq))
Swap the values between two @objtype{mpq} objects.

@lisp
(let ((op1 (mpq))
      (op2 (mpq)))
  (mpq-set-si op1 3 4)
  (mpq-set-si op2 5 6)
  (mpq-swap op1 op2)
  (mpq-get-str 10 op2)  @result{} "3/4"
  (mpq-get-str 10 op1)  @result{} "5/6"
  )
@end lisp
@end deffn

@c page
@node rationals conversion
@section Converting rational numbers to other objects


@deffn {Generic Function} mpq-get-d (@var{OP})
@deffnx {Method} mpq-get-d ((@var{OP} mpq))
Convert an object @var{OP} of type @objtype{mpq} to a floating--point number.

@lisp
(mpq-get-d (mp1 12.3))  @result{} 12.3
@end lisp
@end deffn


@deffn {Generic Function} mpq-get-str (@var{BASE} @var{OP})
@deffnx {Method} mpq-get-str ((@var{BASE} integer) (@var{OP} mpq))
Convert an object @var{OP} of type @objtype{mpq} to a string; return the resulting string.
@var{BASE} must be an exact integer representing the base of the numeric string representation:
positive between @math{2} and @math{36} or negative between @math{-2} and @math{-36}.

@lisp
(defconst op (mpq))
(mpq-set-si op 17 13)

(mpq-get-str +10 op)    @result{} "17/13"
(mpq-get-str +16 op)    @result{} "11/d"
(mpq-get-str -16 op)    @result{} "11/D"
@end lisp
@end deffn

@c page
@node rationals arithmetic
@section Arithmetic operations


@c void mpq_add (mpq_t SUM, const mpq_t ADDEND1, const mpq_t ADDEND2)
@deffn {Generic Function} mpq-add (@var{rop} @vari{op} @varii{op})
@deffnx {Method} mpq-add ((@var{rop} mpq) (@vari{op} mpq) (@varii{op} mpq))
Add two @objtype{mpq} objects.

@lisp
(let ((rop    (mpq))
      (op1    (mpq 2 9))
      (op2    (mpq 3 9)))
  (mpq-add rop op1 op2)
  (mpq-equal (mpq (+ 2 3) 9) rop))
@result{} t
@end lisp
@end deffn


@c void mpq_sub (mpq_t DIFFERENCE, const mpq_t MINUEND, const mpq_t SUBTRAHEND)
@deffn {Generic Function} mpq-sub (@var{difference} @var{minuend} @var{subtrahend})
@deffnx {Method} mpq-sub ((@var{difference} mpq) (@var{minuend} mpq) (@var{subtrahend} mpq))
Set @var{DIFFERENCE} to @var{MINUEND} - @var{SUBTRAHEND}.

@lisp
(let ((difference     (mpq))
      (minuend        (mpq 7 9))
      (subtrahend     (mpq 5 9)))
  (mpq-sub difference minuend subtrahend)
  (mpq-equal (mpq (- 7 5) 9) difference))
@result{} t
@end lisp
@end deffn


@c void mpq_mul (mpq_t PRODUCT, const mpq_t MULTIPLIER, const mpq_t MULTIPLICAND)
@deffn {Generic Function} mpq-mul (@var{product} @var{multiplier} @var{multiplicand})
@deffnx {Method} mpq-mul ((@var{product} mpq) (@var{multiplier} mpq) (@var{multiplicand} mpq))
Set @var{PRODUCT} to @var{MULTIPLIER} times @var{MULTIPLICAND}.

@lisp
(let ((product        (mpq))
      (multiplier     (mpq 2 9))
      (multiplicand   (mpq 4 9)))
  (mpq-mul product multiplier multiplicand)
  (mpq-equal (mpq (* 2 4) (* 9 9)) product))
@result{} t
@end lisp
@end deffn


@c void mpq_mul_2exp (mpq_t ROP, const mpq_t OP1, mp_bitcnt_t OP2)
@deffn {Generic Function} mpq-mul-2exp (@var{rop} @vari{op} @varii{op})
@deffnx {Method} mpq-mul-2exp ((@var{ROP} mpq) (@vari{OP} mpq) (@varii{OP} integer))
Set ROP to OP1 times 2 raised to OP2.

@lisp
(let ((rop    (mpq))
      (op1    (mpq 1 3))
      (op2    3))
  (mpq-mul-2exp rop op1 op2)
  (mpq-equal (mpq 8 3) rop))
@result{} t
@end lisp
@end deffn


@c void mpq_div (mpq_t QUOTIENT, const mpq_t DIVIDEND, const mpq_t DIVISOR)
@deffn {Generic Function} mpq-div (@var{QUOTIENT} @var{DIVIDEND} @var{DIVISOR})
@deffnx {Method} mpq-div ((@var{QUOTIENT} mpq) (@var{DIVIDEND} mpq) (@var{DIVISOR} mpq))
Set @var{QUOTIENT} to @var{DIVIDEND}/@var{DIVISOR}.

@lisp
(let ((quotient       (mpq))
      (dividend       (mpq 4 9))
      (divisor        (mpq 2 3)))
  (mpq-div quotient dividend divisor)
  (mpq-equal (mpq 2 3) quotient))
@result{} t
@end lisp
@end deffn


@c void mpq_div_2exp (mpq_t ROP, const mpq_t OP1, mp_bitcnt_t OP2)
@deffn {Generic Function} mpq-div-2exp (@var{rop} @vari{op} @varii{op})
@deffnx {Method} mpq-div-2exp ((@var{ROP} mpq) (@vari{OP} mpq) (@varii{OP} integer))
Set @var{ROP} to @vari{OP} divided by 2 raised to @varii{OP}.

@lisp
(let ((rop    (mpq))
      (op1    (mpq 16 17))
      (op2    3))
  (mpq-div-2exp rop op1 op2)
  (mpq-equal (mpq (/ 16 (expt 2 3)) 17) rop))
@result{} t
@end lisp
@end deffn

@c void mpq_neg (mpq_t NEGATED_OPERAND, const mpq_t OPERAND)
@deffn {Generic Function} mpq-neg (@var{NEGATED-OPERAND} @var{OPERAND})
@deffnx {Method} mpq-neg ((@var{NEGATED-OPERAND} mpq) (@var{OPERAND} mpq))
Set @var{NEGATED-OPERAND} to -@var{OPERAND}.

@lisp
(let ((negated-operand        (mpq))
      (operand                (mpq 2 3)))
  (mpq-neg negated-operand operand)
  (mpq-equal (mpq -2 3) negated-operand))
@result{} t
@end lisp
@end deffn


@c void mpq_abs (mpq_t ROP, const mpq_t OP)
@deffn {Generic Function} mpq-abs (@var{ROP} @var{OP})
@deffnx {Method} mpq-abs ((@var{ROP} mpq) (@var{OP} mpq))
Set @var{ROP} to the absolute value of @var{OP}.

@lisp
(let ((rop    (mpq))
      (op     (mpq -3 17)))
  (mpq-abs rop op)
  (mpq-equal (mpq 3 17) rop))
@result{} t
@end lisp
@end deffn


@c void mpq_inv (mpq_t INVERTED_NUMBER, const mpq_t NUMBER)
@deffn {Generic Function} mpq-inv (@var{INVERTED-NUMBER} @var{NUMBER})
@deffnx {Method} mpq-inv ((@var{INVERTED-NUMBER} mpq) (@var{NUMBER} mpq))
Set @var{INVERTED-NUMBER} to 1/@var{NUMBER}.

@lisp
(let ((inverted-number        (mpq))
      (number                 (mpq 13 17)))
  (mpq-inv inverted-number number)
  (mpq-equal (mpq 17 13) inverted-number))
@result{} t
@end lisp
@end deffn

@c page
@node rationals comparison
@section Comparison functions


@c int mpq_cmp (const mpq_t OP1, const mpq_t OP2)
@deffn {Generic Function} mpq-cmp (@vari{OP} @varii{OP})
@deffnx {Method} mpq-cmp ((@vari{OP} mpq) (@varii{OP} mpq))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpq-cmp (mpq 1 2) (mpq 3 2))   @result{} -1
(mpq-cmp (mpq 1 2) (mpq 1 2))   @result{}  0
(mpq-cmp (mpq 3 2) (mpq 1 2))   @result{} +1
@end lisp
@end deffn


@c int mpq_cmp_z (const mpq_t OP1, const mpz_t OP2)
@deffn {Generic Function} mpq-cmp-z (@vari{OP} @varii{OP})
@deffnx {Method} mpq-cmp-z ((@vari{OP} mpq) (@varii{OP} mpz))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpq-cmp-z (mpq 1 2) (mpz 1))   @result{} -1
(mpq-cmp-z (mpq 1 1) (mpz 1))   @result{}  0
(mpq-cmp-z (mpq 3 2) (mpz 1))   @result{} +1
@end lisp
@end deffn


@c int mpq_cmp_ui (const mpq_t OP1, unsigned long int NUM2, unsigned long int DEN2)
@deffn {Generic Function} mpq-cmp-ui (@vari{OP} num2 den2)
@deffnx {Method} mpq-cmp-ui ((@vari{OP} mpq) (@varii{NUM} integer) (@varii{DEN} integer))
Compare @vari{OP} and @varii{NUM}/@varii{DEN}.

@lisp
(mpq-cmp-ui (mpq 1 2) 3 2)      @result{} -1
(mpq-cmp-ui (mpq 1 2) 1 2)      @result{}  0
(mpq-cmp-ui (mpq 3 2) 1 2)      @result{} +1
@end lisp
@end deffn


@c int mpq_cmp_si (const mpq_t OP1, long int NUM2, unsigned long int DEN2)
@deffn {Generic Function} mpq-cmp-si (@vari{OP} num2 den2)
@deffnx {Method} mpq-cmp-si ((@vari{OP} mpq) (@varii{NUM} integer) (@varii{DEN} integer))
Compare @vari{OP} and @varii{NUM}/@varii{DEN}.

@lisp
(mpq-cmp-si (mpq -1 2) -3 2)    @result{} +1
(mpq-cmp-si (mpq -1 2) -1 2)    @result{}  0
(mpq-cmp-si (mpq -3 2) -1 2)    @result{} -1
@end lisp
@end deffn


@c int mpq_sgn (const mpq_t OP)
@deffn {Generic Function} mpq-sgn (@var{OP})
@deffnx {Method} mpq-sgn ((@var{OP} mpq))
Return +1 if @var{OP} > 0, 0 if @var{OP} = 0, and -1 if @var{OP} < 0.

@lisp
(mpq-sgn (mpq +1 2))            @result{} +1
(mpq-sgn (mpq  0 2))            @result{}  0
(mpq-sgn (mpq -1 2))            @result{} -1
@end lisp
@end deffn


@c int mpq_equal (const mpq_t OP1, const mpq_t OP)
@deffn {Generic Function} mpq-equal (@vari{OP} @varii{OP})
@deffnx {Method} mpq-equal ((@vari{OP} mpq) (@varii{OP} mpq))
Return non-zero if @vari{OP} and @varii{OP} are equal, zero if they are non-equal.

@lisp
(mpq-equal (mpq 1 2) (mpq 1 2)) @result{} t
(mpq-equal (mpq 1 2) (mpq 3 2)) @result{} nil
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpq-zero-p (@var{OP})
@deffnx {Method} mpq-zero-p ((@var{OP} mpq))
Return true if @var{OP} is zero; otherwise return false.

@lisp
(mpq-zero-p (mpq -1 2))         @result{} nil
(mpq-zero-p (mpq  0 2))         @result{} t
(mpq-zero-p (mpq +1 2))         @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpq-non-zero-p (@var{OP})
@deffnx {Method} mpq-non-zero-p ((@var{OP} mpq))
Return true if @var{OP} is non-zero; otherwise return false.

@lisp
(mpq-non-zero-p (mpq -1 2))     @result{} t
(mpq-non-zero-p (mpq  0 2))     @result{} nil
(mpq-non-zero-p (mpq +1 2))     @result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpq-positive-p (@var{OP})
@deffnx {Method} mpq-positive-p ((@var{OP} mpq))
Return true if @var{OP} is strictly positive; otherwise return false.

@lisp
(mpq-positive-p (mpq -1 2))     @result{} nil
(mpq-positive-p (mpq  0 2))     @result{} nil
(mpq-positive-p (mpq +1 2))     @result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpq-negative-p (@var{OP})
@deffnx {Method} mpq-negative-p ((@var{OP} mpq))
Return true if @var{OP} is strictly negative; otherwise return false.

@lisp
(mpq-negative-p (mpq -1 2))     @result{} t
(mpq-negative-p (mpq  0 2))     @result{} nil
(mpq-negative-p (mpq +1 2))     @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpq-non-positive-p (@var{OP})
@deffnx {Method} mpq-non-positive-p ((@var{OP} mpq))
Return true if @var{OP} is non-positive; otherwise return false.

@lisp
(mpq-non-positive-p (mpq -1 2)) @result{} t
(mpq-non-positive-p (mpq  0 2)) @result{} t
(mpq-non-positive-p (mpq +1 2)) @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpq-non-negative-p (@var{OP})
@deffnx {Method} mpq-non-negative-p ((@var{OP} mpq))
Return true if @var{OP} is non-negative; otherwise return false.

@lisp
(mpq-non-negative-p (mpq -1 2)) @result{} nil
(mpq-non-negative-p (mpq  0 2)) @result{} t
(mpq-non-negative-p (mpq +1 2)) @result{} t
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpq< (@var{OP} &rest @var{OPS})
@deffnx {Method} mpq< ((@vari{OP} mpq) (@varii{OP} mpq))
Return true if each argument is strictly less than the following argument; otherwise return false.

@lisp
(mpq< (mpq 1 2) (mpq 2 2))      @result{} t
(mpq< (mpq 1 2) (mpq 1 2))      @result{} nil
(mpq< (mpq 2 2) (mpq 1 2))      @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpq> (@var{OP} &rest @var{OPS})
@deffnx {Method} mpq> ((@vari{OP} mpq) (@varii{OP} mpq))
Return true if each argument is strictly greater than the following argument; otherwise return
false.

@lisp
(mpq> (mpq 1 2) (mpq 2 2))      @result{} nil
(mpq> (mpq 1 2) (mpq 1 2))      @result{} nil
(mpq> (mpq 2 2) (mpq 1 2))      @result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpq<= (@var{OP} &rest @var{OPS})
@deffnx {Method} mpq<= ((@vari{OP} mpq) (@varii{OP} mpq))
Return true if each argument is strictly less than, or equal to, the following argument; otherwise
return false.

@lisp
(mpq<= (mpq 1 2) (mpq 2 2))     @result{} t
(mpq<= (mpq 1 2) (mpq 1 2))     @result{} t
(mpq<= (mpq 2 2) (mpq 1 2))     @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpq>= (@var{OP} &rest @var{OPS})
@deffnx {Method} mpq>= ((@vari{OP} mpq) (@varii{OP} mpq))
Return true if each argument is greater than, or equal to, the following argument; otherwise return
false.

@lisp
(mpq>= (mpq 1 2) (mpq 2 2))     @result{} nil
(mpq>= (mpq 1 2) (mpq 1 2))     @result{} t
(mpq>= (mpq 2 2) (mpq 1 2))     @result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpq= (@var{OP} &rest @var{OPS})
@deffnx {Method} mpq= ((@vari{OP} mpq) (@varii{OP} mpq))
Return true if each argument is equal to the following argument; otherwise return false.

@lisp
(mpq= (mpq 1 2) (mpq 2 2))      @result{} nil
(mpq= (mpq 1 2) (mpq 1 2))      @result{} t
(mpq= (mpq 2 2) (mpq 1 2))      @result{} nil
@end lisp
@end deffn

@c page
@node floats
@chapter Floating-point number objects and operations


@deftp {Object Type} mpf
Type of structures representing a multiple precision floating--point numbers.  It is a wrapper for
the C language type @objtype{mpf_t}.  These objects, and their internal representation, are
correctly garbage collected.
@end deftp


@menu
* floats allocation::           Allocating floating-point numbers.
* floats initialisation::       Floating-point numbers initialisation
                                functions.
* floats predicates::           Floating-point number predicates.
* floats assignment::           Assigning values to floating-point
                                number objects.
* floats conversion::           Converting floating-point numbers to
                                other objects.
* floats arithmetic::           Arithmetic operations.
* floats comparison::           Comparison functions.
* floats misc::                 Miscellaneous functions.
@end menu

@c page
@node floats allocation
@section Allocating floating--point numbers


@defun mpf &optional @var{INIT}
Build and return a new @objtype{mpf} object instance.  When called with no arguments: the object is
uninitialised.

When the @var{INIT} argument is provided: it must be an initialisation value for the @objtype{mpf}
object.  I can be: an exact integer number; a floating--point number; an @objtype{mpz} object; an
@objtype{mpq} object; an @objtype{mpf} object.

@lisp
(let ((op (mpf 123)))
  (mpf-get-str* 10 5 op))
@result{} "+0.123e+3"
@end lisp

When the @var{INIT} argument is missing: the returned object is set to zero.

@lisp
(let ((op (mpf)))
  (mpf-get-str* 10 5 op))
@result{} "0.0"
@end lisp
@end defun

@c page
@node floats initialisation
@section Floating--point numbers initialisation functions


@deffn {Generic Function} mpf-set-default-prec (@var{prec})
@deffnx {Method} mpf-set-default-prec ((@var{prec} integer))
Set the default precision of @objtype{mpf} object to at least @var{prec}, which must be an exact
integer number object.
@end deffn


@deffn {Generic Function} mpf-get-default-prec
@deffnx {Method} mpf-get-default-prec
Return an exact integer number representing the current default precision of (@objtype{mpf} objects.)
@end deffn


@deffn {Generic Function} mpf-set-prec (@var{ROP} @var{prec})
@deffnx {Method} mpf-set-prec ((@var{ROP} mpf) (@var{prec} integer))
Set the precision of the @objtype{mpf} object @var{ROP} to at least @var{prec}, which must be an
exact integer number object.
@end deffn


@deffn {Generic Function} mpf-get-prec (@var{ROP})
@deffnx {Method} mpf-get-prec ((@var{ROP} integer))
Return an exact integer number representing the precision of the @objtype{mpf} object @var{ROP}.
@end deffn

@c page
@node floats predicates
@section Floating--point number predicates


@defun mpf-p @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{mpf}; otherwise return @false{}.

@lisp
(mpf-p (mpf))   @result{} t
(mpf-p 123)     @result{} nil
@end lisp
@end defun

@c page
@node floats assignment
@section Assigning values to floating--point number objects


@deffn {Generic Function} mpf-set (@var{ROP} @var{OP})
@deffnx {Method} mpf-set ((@var{ROP} mpf) (@var{OP} mpf))
Assign the value of @var{OP} to @var{ROP}; both the operands must be of type @objtype{mpf}.

@lisp
(defconst rop (mpf))
(defconst op  (mpf))
(mpf-set-si rop 123)
(mpf-set    op rop)
(mpf-get-str* 10 8 op)  @result{} "+0.123e+3"
@end lisp
@end deffn


@deffn {Generic Function} mpf-set-si (@var{ROP} @var{INT})
@deffnx {Method} mpf-set-si ((@var{ROP} mpf) (@var{INT} integer))
Assign the value of an exact integer object to an @objtype{mpf} object.

@lisp
(defconst rop (mpf))
(mpf-set-si rop 123)
(mpf-get-str* 10 8 rop) @result{} "+0.123e+3"
@end lisp
@end deffn


@deffn {Generic Function} mpf-set-ui (@var{ROP} @var{INT})
@deffnx {Method} mpf-set-ui ((@var{ROP} mpf) (@var{INT} integer))
Assign the value of an exact integer object to an @objtype{mpf} object.

@lisp
(defconst rop (mpf))
(mpf-set-ui rop 123)
(mpf-get-str* 10 8 rop) @result{} "+0.123e+3"
@end lisp
@end deffn


@deffn {Generic Function} mpf-set-d (@var{ROP} @var{flo})
@deffnx {Method} mpf-set-d ((@var{ROP} mpf) (@var{FLO} float))
Assign the value of a floating--point object to an @objtype{mpf} object.

@lisp
(let ((rop (mpf)))
  (mpf-set-d rop 12.3)
  (mpf-get-str* 10 8 rop))
@result{} "+0.123e+2"
@end lisp
@end deffn


@deffn {Generic Function} mpf-set-z (@var{ROP} @var{OP})
@deffnx {Method} mpf-set-z ((@var{ROP} mpf) (@var{OP} mpz))
Assign the value of an @objtype{mpz} object to an @objtype{mpf} object.

@lisp
(let ((rop    (mpf))
      (op     (mpz 123)))
  (mpf-set-z rop op)
  (mpf-get-str* 10 8 rop))
@result{} "+0.123e+3"
@end lisp
@end deffn


@deffn {Generic Function} mpf-set-q (@var{ROP} @var{OP})
@deffnx {Method} mpf-set-q ((@var{ROP} mpf) (@var{OP} mpq))
Assign the value of an @objtype{mpq} object to an @objtype{mpf} object.

@lisp
(let ((rop    (mpf))
      (op     (mpq 2 3)))
  (mpf-set-q rop op)
  (mpf-get-str* 10 8 rop))
@result{} "+0.66666667e0"
@end lisp
@end deffn


@deffn {Generic Function} mpf-set-str (@var{ROP} @var{STR} @var{BASE})
@deffnx {Method} mpf-set-str ((@var{ROP} mpf) (@var{STR} string) (@var{BASE} integer))
Assign the value of a string object to an @objtype{mpf} object.  The argument @var{BASE} must be an
exact integer representing the base of the numeric string representation: a positive value between
@math{2} and @math{62} or a negative value between @math{-2} and @math{-62}.

@lisp
(let ((rop (mpf)))
  (mpf-set-str rop "123" 10)
  (mpf-get-str* 10 8 rop))
@result{} "+0.123e+3"
@end lisp
@end deffn


@deffn {Generic Function} mpf-swap (@vari{OP} @varii{OP})
@deffnx {Method} mpf-swap ((@vari{OP} mpf) (@varii{OP} mpf))
Swap the values between two @objtype{mpf} objects.

@lisp
(let ((op1 (mpf))
      (op2 (mpf)))
  (mpf-set-si op1 123)
  (mpf-set-si op2 456)
  (mpf-swap op1 op2)
  (mpf-get-str* 10 8 op2)       @result{} "+0.123e+3"
  (mpf-get-str* 10 8 op1))      @result{} "+0.456e+3"
@end lisp
@end deffn

@c page
@node floats conversion
@section Converting floating--point numbers to other objects


@deffn {Generic Function} mpf-get-ui (@var{OP})
@deffnx {Method} mpf-get-ui ((@var{OP} mpf))
Convert an object @var{OP} of type @objtype{mpf} to an unsigned exact integer number.

@lisp
(mpf-get-ui (mpf 123))  @result{} 123
@end lisp
@end deffn


@deffn {Generic Function} mpf-get-si (@var{OP})
@deffnx {Method} mpf-get-si ((@var{OP} mpf))
Convert an object @var{OP} of type @objtype{mpf} to an signed exact integer number.

@lisp
(mpf-get-si (mpf 123))  @result{} 123
@end lisp
@end deffn


@deffn {Generic Function} mpf-get-d (@var{OP})
@deffnx {Method} mpf-get-d ((@var{OP} mpf))
Convert an object @var{OP} of type @objtype{mpf} to a floating--point number.

@lisp
(mpf-get-d (mpf 123))  @result{} 123.0
@end lisp
@end deffn


@deffn {Generic Function} mpf-get-d-2exp (@var{OP})
@deffnx {Method} mpf-get-d-2exp ((@var{OP} mpf))
Convert an object @var{OP} of type @objtype{mpf} to a floating--point number, yielding the exponent
separately.  The return value is a pair whose car is a floating--point number and whose cdr is the
exponent:

@lisp
(defconst rv (mpf-get-d-2exp (mpf 123)))

rv                                      @result{} (0.9609375 . 7)
(* (car rv) (expt 2 (cdr rv)))          @result{} 123.0
@end lisp
@end deffn


@deffn {Generic Function} mpf-get-str (@var{BASE} @var{NDIGITS} @var{OP})
@deffnx {Method} mpf-get-str ((@var{BASE} integer) (@var{NDIGITS} integer) (@var{OP} mpf))
Convert an object @var{OP} of type @objtype{mpf} to a string; return a pair object whose car is a
string representing the mantissa and whose cdr is an exact integer representing the exponent.

The arguments @var{BASE} must be an exact integer representing the base of the numeric string
representation: positive between @math{+2} and @math{+62} or negative between @math{-2} and
@math{-36}.

The argument @var{NDIGITS} must be an exact integer representing the number of digits to generate.

@lisp
(let ((op       (mpf 15))
      (ndigits  5))
  (mpf-get-str +10 ndigits op)  @result{} ("15" . 2)
  (mpf-get-str +16 ndigits op)  @result{} ("f"  . 1)
  (mpf-get-str -16 ndigits op)  @result{} ("F"  . 1)
  )

(let ((op       (mpf))
      (ndigits  5))
  (mpf-set-d op 12.34)
  (mpf-get-str +10 ndigits op))
@result{} ("1234" . 2)
@end lisp
@end deffn


@deffn {Generic Function} mpf-get-str* (@var{BASE} @var{NDIGITS} @var{OP})
@deffnx {Method} mpf-get-str* ((@var{BASE} integer) (@var{NDIGITS} integer) (@var{OP} mpf))
Convert an object @var{OP} of type @objtype{mpf} to a formatted string; return the string.  The
arguments @var{BASE} and @var{NDIGITS} are the same as documented for @func{mpf-get-str}.

@lisp
(let ((op       (mpf))
      (ndigits  5))
  (mpf-set-d op +0.001234)
  (mpf-get-str* +10 ndigits op))
@result{} "+0.1234e-2"

(let ((op       (mpf))
      (ndigits  5))
  (mpf-set-d op +12.34)
  (mpf-get-str* +10 ndigits op))
@result{} "+0.1234e+2"

(mpf-get-str* 10 5 (mpf))
@result{} "0.0"
@end lisp
@end deffn

@c page
@node floats arithmetic
@section Arithmetic operations


@c mpf_add (mpf_t ROP, const mpf_t OP1, const mpf_t OP2)
@deffn {Generic Function} mpf-add (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-add ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} mpf))
Set @var{ROP} to @vari{OP} + @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    (mpf 3.4)))
  (mpf-add rop op1 op2)
  (mpf-almost-equal-p rop (+ 1.2 3.4) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_add_ui (mpf_t ROP, const mpf_t OP1, unsigned long int OP2)
@deffn {Generic Function} mpf-add-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-add-ui ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} integer))
Set @var{ROP} to @vari{OP} + @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    3))
  (mpf-add-ui rop op1 op2)
  (mpf-almost-equal-p rop (+ 1.2 3.0) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_sub (mpf_t ROP, const mpf_t OP1, const mpf_t OP2)
@deffn {Generic Function} mpf-sub (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-sub ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} mpf))
Set @var{ROP} to @vari{OP} - @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    (mpf 3.4)))
  (mpf-sub rop op1 op2)
  (mpf-almost-equal-p rop (- 1.2 3.4) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_ui_sub (mpf_t ROP, unsigned long int OP1, const mpf_t OP2)
@deffn {Generic Function} mpf-ui-sub (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-ui-sub ((@var{ROP} mpf) (@vari{OP} integer) (@varii{OP} mpf))
Set @var{ROP} to @vari{OP} - @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    1)
      (op2    (mpf 3.4)))
  (mpf-ui-sub rop op1 op2)
  (mpf-almost-equal-p rop (- 1 3.4) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_sub_ui (mpf_t ROP, const mpf_t OP1, unsigned long int OP2)
@deffn {Generic Function} mpf-sub-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-sub-ui ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} integer))
Set @var{ROP} to @vari{OP} - @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    3))
  (mpf-sub-ui rop op1 op2)
  (mpf-almost-equal-p rop (- 1.2 3) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_mul (mpf_t ROP, const mpf_t OP1, const mpf_t OP2)
@deffn {Generic Function} mpf-mul (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-mul ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} mpf))
Set @var{ROP} to @vari{OP} times @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    (mpf 3.4)))
  (mpf-mul rop op1 op2)
  (mpf-almost-equal-p rop (* 1.2 3.4) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_mul_ui (mpf_t ROP, const mpf_t OP1, unsigned long int OP2)
@deffn {Generic Function} mpf-mul-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-mul-ui ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} integer))
Set @var{ROP} to @vari{OP} times @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    3))
  (mpf-mul-ui rop op1 op2)
  (mpf-almost-equal-p rop (* 1.2 3) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_div (mpf_t ROP, const mpf_t OP1, const mpf_t OP2)
@deffn {Generic Function} mpf-div (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-div ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} mpf))
Set @var{ROP} to @vari{OP}/@varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    (mpf 3.4)))
  (mpf-div rop op1 op2)
  (mpf-almost-equal-p rop (/ 1.2 3.4) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_ui_div (mpf_t ROP, unsigned long int OP1, const mpf_t OP2)
@deffn {Generic Function} mpf-ui-div (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-ui-div ((@var{ROP} mpf) (@vari{OP} integer) (@varii{OP} mpf))
Set @var{ROP} to @vari{OP}/@varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    1)
      (op2    (mpf 3.4)))
  (mpf-ui-div rop op1 op2)
  (mpf-almost-equal-p rop (/ 1 3.4) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_div_ui (mpf_t ROP, const mpf_t OP1, unsigned long int OP2)
@deffn {Generic Function} mpf-div-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-div-ui ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} integer))
Set @var{ROP} to @vari{OP}/@varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    3))
  (mpf-div-ui rop op1 op2)
  (mpf-almost-equal-p rop (/ 1.2 3) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_sqrt (mpf_t ROP, const mpf_t OP)
@deffn {Generic Function} mpf-sqrt (rop op)
@deffnx {Method} mpf-sqrt ((@var{ROP} mpf) (op mpf))
Set @var{ROP} to the square root of @var{OP}.

@lisp
(let ((rop    (mpf))
      (op     (mpf 1.2)))
  (mpf-sqrt rop op)
  (mpf-almost-equal-p rop (sqrt 1.2) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_sqrt_ui (mpf_t ROP, unsigned long int OP)
@deffn {Generic Function} mpf-sqrt-ui (rop op)
@deffnx {Method} mpf-sqrt-ui ((@var{ROP} mpf) (op integer))
Set @var{ROP} to the square root of @var{OP}.

@lisp
(let ((rop    (mpf))
      (op     12))
  (mpf-sqrt-ui rop op)
  (mpf-almost-equal-p rop (sqrt 12) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_pow_ui (mpf_t ROP, const mpf_t OP1, unsigned long int OP2)
@deffn {Generic Function} mpf-pow-ui (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-pow-ui ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} integer))
Set @var{ROP} to @vari{OP} raised to the power @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    3))
  (mpf-pow-ui rop op1 op2)
  (mpf-almost-equal-p rop (expt 1.2 3) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_neg (mpf_t ROP, const mpf_t OP)
@deffn {Generic Function} mpf-neg (rop op)
@deffnx {Method} mpf-neg ((@var{ROP} mpf) (op mpf))
Set @var{ROP} to -@var{OP}.

@lisp
(let ((rop    (mpf))
      (op     (mpf 1.2)))
  (mpf-neg rop op)
  (mpf-almost-equal-p rop (- 1.2) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_abs (mpf_t ROP, const mpf_t OP)
@deffn {Generic Function} mpf-abs (rop op)
@deffnx {Method} mpf-abs ((@var{ROP} mpf) (op mpf))
Set @var{ROP} to the absolute value of @var{OP}.

@lisp
(let ((rop    (mpf))
      (op     (mpf -1.2)))
  (mpf-abs rop op)
  (mpf-almost-equal-p rop 1.2 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_mul_2exp (mpf_t ROP, const mpf_t OP1, mp_bitcnt_t OP2)
@deffn {Generic Function} mpf-mul-2exp (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-mul-2exp ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} integer))
Set @var{ROP} to @vari{OP} times 2 raised to @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    3))
  (mpf-mul-2exp rop op1 op2)
  (mpf-almost-equal-p rop (* 1.2 (expt 2 3)) 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_div_2exp (mpf_t ROP, const mpf_t OP1, mp_bitcnt_t OP2)
@deffn {Generic Function} mpf-div-2exp (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-div-2exp ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} integer))
Set @var{ROP} to @vari{OP} divided by 2 raised to @varii{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    3))
  (mpf-div-2exp rop op1 op2)
  (mpf-almost-equal-p rop (/ 1.2 (expt 2 3)) 1e-5))
@result{} t
@end lisp
@end deffn

@c page
@node floats comparison
@section Comparison functions


@c int mpf_cmp (const mpf_t OP1, const mpf_t OP2)
@deffn {Generic Function} mpf-cmp (@vari{OP} @varii{OP})
@deffnx {Method} mpf-cmp ((@vari{OP} mpf) (@varii{OP} mpf))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpf-cmp (mpf 1.2) (mpf 3.4))           @result{} -1
(mpf-cmp (mpf 1.2) (mpf 1.2))           @result{}  0
(mpf-cmp (mpf 3.4) (mpf 1.2)))          @result{} +1
@end lisp
@end deffn


@c int mpf_cmp_z (const mpf_t OP1, const mpz_t OP2)
@deffn {Generic Function} mpf-cmp-z (@vari{OP} @varii{OP})
@deffnx {Method} mpf-cmp-z ((@vari{OP} mpf) (@varii{OP} mpz))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpf-cmp-z (mpf 1.2) (mpz 2))           @result{} -1
(mpf-cmp-z (mpf 1.0) (mpz 1))           @result{}  0
(mpf-cmp-z (mpf 1.2) (mpz 1))           @result{} +1
@end lisp
@end deffn


@c int mpf_cmp_d (const mpf_t OP1, double OP2)
@deffn {Generic Function} mpf-cmp-d (@vari{OP} @varii{OP})
@deffnx {Method} mpf-cmp-d ((@vari{OP} mpf) (@varii{OP} float))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpf-cmp-d (mpf 1.2) 3.4)               @result{} -1
(mpf-cmp-d (mpf 1.2) 1.2)               @result{}  0
(mpf-cmp-d (mpf 3.4) 1.2)               @result{} +1
@end lisp
@end deffn


@c int mpf_cmp_ui (const mpf_t OP1, unsigned long int OP2)
@deffn {Generic Function} mpf-cmp-ui (@vari{op} @varii{op})
@deffnx {Method} mpf-cmp-ui ((@vari{OP} mpf) (@varii{OP} integer))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpf-cmp-ui (mpf 1.2) 2)                @result{} -1
(mpf-cmp-ui (mpf 1.0) 1)                @result{}  0
(mpf-cmp-ui (mpf 1.2) 1)                @result{} +1
@end lisp
@end deffn


@c int mpf_cmp_si (const mpf_t OP1, long int OP2)
@deffn {Generic Function} mpf-cmp-si (@vari{OP} @varii{OP})
@deffnx {Method} mpf-cmp-si ((@vari{OP} mpf) (@varii{OP} integer))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpf-cmp-si (mpf -2.1) -2)              @result{} -1
(mpf-cmp-si (mpf -1.0) -1)              @result{}  0
(mpf-cmp-si (mpf -1.0) -2)              @result{} +1
@end lisp
@end deffn


@c int mpf_sgn (const mpf_t OP)
@deffn {Generic Function} mpf-sgn (@var{OP})
@deffnx {Method} mpf-sgn ((@var{OP} mpf))
Return +1 if @var{OP} > 0, 0 if @var{OP} = 0, and -1 if @var{OP} < 0.

@lisp
(mpf-sgn (mpf -1.0))            @result{} -1
(mpf-sgn (mpf  0.0))            @result{}  0
(mpf-sgn (mpf +1.0))            @result{} +1
@end lisp
@end deffn


@c void mpf_reldiff (mpf_t ROP, const mpf_t OP1, const mpf_t OP2)
@deffn {Generic Function} mpf-reldiff (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpf-reldiff ((@var{ROP} mpf) (@vari{OP} mpf) (@varii{OP} mpf))
Compute the relative difference between @vari{OP} and @varii{OP} and store the result in @var{ROP}.  This
is abs(@vari{OP}-@varii{OP})/@vari{OP}.

@lisp
(let ((rop    (mpf))
      (op1    (mpf 1.2))
      (op2    (mpf 3.4)))
  (mpf-reldiff rop op1 op2)
  (let ((X (/ (abs (- 1.2 3.4)) 1.2)))
    (< (- X 0.00001)
       (mpf-get-d rop)
       (+ X 0.00001))))
@result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpf-equal (@vari{OP} @varii{OP})
@deffnx {Method} mpf-equal ((@vari{OP} mpf) (@varii{OP} mpf))
Return true the operands are equal; otherwise return false.

@lisp
(mpf-equal (mpf 1.2) (mpf 1.2)))                @result{} t
(mpf-equal (mpf 1.2) (mpf 3.4)))))              @result{} nil
@end lisp
@end deffn

@c --------------------------------------------------------------------

@deffn {Generic Function} mpf-zero-p (@var{OP})
@deffnx {Method} mpf-zero-p ((@var{OP} mpf))
Return true if @var{OP} is zero; otherwise return false.

@lisp
(mpf-zero-p (mpf 0.0)))         @result{} t
(mpf-zero-p (mpf 1.0)))))       @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpf-non-zero-p (@var{OP})
@deffnx {Method} mpf-non-zero-p ((@var{OP} mpf))
Return true if @var{OP} is non-zero; otherwise return false.

@lisp
(mpf-non-zero-p (mpf 1.0)))     @result{} t
(mpf-non-zero-p (mpf 0.0)))     @result{} nil
@end lisp
@end deffn

@c --------------------------------------------------------------------

@deffn {Generic Function} mpf-positive-p (@var{OP})
@deffnx {Method} mpf-positive-p ((@var{OP} mpf))
Return true if @var{OP} is strictly positive; otherwise return false.

@lisp
(mpf-positive-p (mpf +1.0)))    @result{} t
(mpf-positive-p (mpf  0.0)))    @result{} nil
(mpf-positive-p (mpf -1.0)))    @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpf-negative-p (@var{OP})
@deffnx {Method} mpf-negative-p ((@var{OP} mpf))
Return true if @var{OP} is strictly negative; otherwise return false.

@lisp
(mpf-negative-p (mpf +1.0))     @result{} nil
(mpf-negative-p (mpf  0.0))     @result{} nil
(mpf-negative-p (mpf -1.0))     @result{} t
@end lisp
@end deffn

@c --------------------------------------------------------------------

@deffn {Generic Function} mpf-non-positive-p (@var{OP})
@deffnx {Method} mpf-non-positive-p ((@var{OP} mpf))
Return true if @var{OP} is non-positive; otherwise return false.

@lisp
(mpf-non-positive-p (mpf +1.0)) @result{} nil
(mpf-non-positive-p (mpf  0.0)) @result{} t
(mpf-non-positive-p (mpf -1.0)) @result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpf-non-negative-p (@var{OP})
@deffnx {Method} mpf-non-negative-p ((@var{OP} mpf))
Return true if @var{OP} is non-negative; otherwise return false.

@lisp
(mpf-non-negative-p (mpf +1.0)) @result{} t
(mpf-non-negative-p (mpf  0.0)) @result{} t
(mpf-non-negative-p (mpf -1.0)) @result{} nil
@end lisp
@end deffn

@c --------------------------------------------------------------------

@deffn {Generic Function} mpf< (@var{OP} &rest @var{OPS})
@deffnx {Method} mpf< ((@vari{OP} mpf) (@varii{OP} mpf))
Return true if each argument is strictly less than the following argument; otherwise return false.

@lisp
(mpf< (mpf 1.0) (mpf 2.0))      @result{} t
(mpf< (mpf 1.0) (mpf 1.0))      @result{} nil
(mpf< (mpf 2.0) (mpf 1.0))      @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpf> (@var{OP} &rest @var{OPS})
@deffnx {Method} mpf> ((@vari{OP} mpf) (@varii{OP} mpf))
Return true if each argument is strictly greater than the following argument; otherwise return
false.

@lisp
(mpf> (mpf 1.0) (mpf 2.0))      @result{} nil
(mpf> (mpf 1.0) (mpf 1.0))      @result{} nil
(mpf> (mpf 2.0) (mpf 1.0))      @result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpf<= (@var{OP} &rest @var{OPS})
@deffnx {Method} mpf<= ((@vari{OP} mpf) (@varii{OP} mpf))
Return true if each argument is strictly less than, or equal to, the following argument; otherwise
return false.

@lisp
(mpf<= (mpf 1.0) (mpf 2.0)))    @result{} t
(mpf<= (mpf 1.0) (mpf 1.0)))    @result{} t
(mpf<= (mpf 2.0) (mpf 1.0)))    @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpf>= (@var{OP} &rest @var{OPS})
@deffnx {Method} mpf>= ((@vari{OP} mpf) (@varii{OP} mpf))
Return true if each argument is greater than, or equal to, the following argument; otherwise return
false.

@lisp
(mpf>= (mpf 1.0) (mpf 2.0))     @result{} nil
(mpf>= (mpf 1.0) (mpf 1.0))     @result{} t
(mpf>= (mpf 2.0) (mpf 1.0))     @result{} t
@end lisp
@end deffn


@deffn {Generic Function} mpf= (@var{OP} &rest @var{OPS})
@deffnx {Method} mpf= ((@vari{OP} mpf) (@varii{OP} mpf))
Return true if each argument is equal to the following argument; otherwise return false.

@lisp
(mpf= (mpf 1.0) (mpf 2.0))      @result{} nil
(mpf= (mpf 1.0) (mpf 1.0))      @result{} t
(mpf= (mpf 2.0) (mpf 1.0))      @result{} nil
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpf-almost-equal-p (@vari{OP} @varii{OP} @var{TOL})
@deffnx {Method} mpf-almost-equal-p ((@vari{OP} mpf) (@varii{OP} mpf) (@var{TOL} mpf))
@deffnx {Method} mpf-almost-equal-p ((@vari{OP} mpf) (@varii{OP} mpf) (@var{TOL} float))
@deffnx {Method} mpf-almost-equal-p ((@vari{OP} mpf) (@varii{OP} float) (@var{TOL} float))
Return true if abs(@vari{OP} - @varii{OP}) < @var{TOL}.
@end deffn

@c page
@node floats misc
@section Miscellaneous functions


@c void mpf_ceil (mpf_t ROP, const mpf_t OP)
@deffn {Generic Function} mpf-ceil (@var{ROP} @var{OP})
@deffnx {Method} mpf-ceil ((@var{ROP} mpf) (@var{OP} mpf))
Set @var{ROP} to @var{OP} rounded to an integer.

@lisp
(let ((rop    (mpf))
      (op     (mpf 1.5)))
  (mpf-ceil rop op)
  (mpf-almost-equal-p rop 2.0 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_floor (mpf_t ROP, const mpf_t OP)
@deffn {Generic Function} mpf-floor (@var{ROP} @var{OP})
@deffnx {Method} mpf-floor ((@var{ROP} mpf) (@var{OP} mpf))
Set @var{ROP} to @var{OP} rounded to an integer.

@lisp
(let ((rop    (mpf))
      (op     (mpf 1.5)))
  (mpf-floor rop op)
  (mpf-almost-equal-p rop 1.0 1e-5))
@result{} t
@end lisp
@end deffn


@c void mpf_trunc (mpf_t ROP, const mpf_t OP)
@deffn {Generic Function} mpf-trunc (@var{ROP} @var{OP})
@deffnx {Method} mpf-trunc ((@var{ROP} mpf) (@var{OP} mpf))
Set @var{ROP} to @var{OP} rounded to an integer.

@lisp
(let ((rop    (mpf))
      (op     (mpf 1.5)))
  (mpf-trunc rop op)
  (mpf-almost-equal-p rop 1.0 1e-5))
@result{} t
@end lisp
@end deffn


@c int mpf_integer_p (const mpf_t OP)
@deffn {Generic Function} mpf-integer-p (@var{OP})
@deffnx {Method} mpf-integer-p ((@var{OP} mpf))
Return true if @var{OP} is an integer.

@lisp
(mpf-integer-p (mpf 1.0))       @result{} t
(mpf-integer-p (mpf 1.1))       @result{} nil
@end lisp
@end deffn


@c int mpf_fits_ulong_p (const mpf_t OP)
@deffn {Generic Function} mpf-fits-ulong-p (@var{OP})
@deffnx {Method} mpf-fits-ulong-p ((@var{OP} mpf))
Return true if @var{OP} would fit in the respective C data type, when truncated to an integer.

@lisp
(mpf-fits-ulong-p (mpf 1.2))    @result{} t
(mpf-fits-ulong-p (mpf 1.0e99)) @result{} nil
@end lisp
@end deffn


@c int mpf_fits_slong_p (const mpf_t OP)
@deffn {Generic Function} mpf-fits-slong-p (@var{OP})
@deffnx {Method} mpf-fits-slong-p ((@var{OP} mpf))
Return true if @var{OP} would fit in the respective C data type, when truncated to an integer.

@lisp
(mpf-fits-slong-p (mpf 1.2))    @result{} t
(mpf-fits-slong-p (mpf 1.0e99)) @result{} nil
@end lisp
@end deffn


@c int mpf_fits_uint_p (const mpf_t OP)
@deffn {Generic Function} mpf-fits-uint-p (@var{OP})
@deffnx {Method} mpf-fits-uint-p ((@var{OP} mpf))
Return true if @var{OP} would fit in the respective C data type, when truncated to an integer.

@lisp
(mpf-fits-uint-p (mpf 1.2))     @result{} t
(mpf-fits-uint-p (mpf 1.0e99))  @result{} nil
@end lisp
@end deffn


@c int mpf_fits_sint_p (const mpf_t OP)
@deffn {Generic Function} mpf-fits-sint-p (@var{OP})
@deffnx {Method} mpf-fits-sint-p ((@var{OP} mpf))
Return true if @var{OP} would fit in the respective C data type, when truncated to an integer.

@lisp
(mpf-fits-sint-p (mpf 1.2))     @result{} t
(mpf-fits-sint-p (mpf 1.0e99))  @result{} nil
@end lisp
@end deffn


@c int mpf_fits_ushort_p (const mpf_t OP)
@deffn {Generic Function} mpf-fits-ushort-p (@var{OP})
@deffnx {Method} mpf-fits-ushort-p ((@var{OP} mpf))
Return true if @var{OP} would fit in the respective C data type, when truncated to an integer.

@lisp
(mpf-fits-ushort-p (mpf 1.2))           @result{} t
(mpf-fits-ushort-p (mpf 1.0e99))        @result{} nil
@end lisp
@end deffn


@c int mpf_fits_sshort_p (const mpf_t OP)
@deffn {Generic Function} mpf-fits-sshort-p (@var{OP})
@deffnx {Method} mpf-fits-sshort-p ((@var{OP} mpf))
Return true if @var{OP} would fit in the respective C data type, when truncated to an integer.

@lisp
(mpf-fits-sshort-p (mpf 1.2))           @result{} t
(mpf-fits-sshort-p (mpf 1.0e99))        @result{} nil
@end lisp
@end deffn


@c void mpf_urandomb (mpf_t ROP, gmp_randstate_t STATE, mp_bitcnt_t NBITS)
@deffn {Generic Function} mpf-urandomb (@var{ROP} @var{STATE} @var{NBITS})
@deffnx {Method} mpf-urandomb ((@var{ROP} mpf) (@var{STATE} gmp-randstate) (@var{NBITS} integer))
Generate a uniformly distributed random float in @var{ROP}.

@lisp
(let ((rop    (mpf))
      (state  (gmp-randstate))
      (nbits  3))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpf-urandomb rop state nbits)
  (mpf<= 0 rop)         @result{} t
  (mpf<  rop 1.0))      @result{} t
@end lisp
@end deffn


@c void mpf_random2 (mpf_t ROP, mp_size_t MAX_SIZE, mp_exp_t EXP)
@deffn {Generic Function} mpf-random2 (@var{ROP} @var{MAX-SIZE} @var{EXP})
@deffnx {Method} mpf-random2 ((@var{ROP} mpf) (@var{MAX-SIZE} integer) (@var{EXP} integer))
Generate a random float of at most @var{MAX-SIZE} limbs, with long strings of zeros and ones in the
binary representation.

@lisp
(let ((rop            (mpf))
      (max-size       1)
      (exp            3))
  (mpf-random2 rop max-size exp)
  (mpf-p rop))
@result{} t
@end lisp
@end deffn

@c page
@node random
@chapter Random numbers generation


@deftp {Object Type} gmp-randstate
Type of structures representing the state of a random numbers generator.  It is a wrapper for the C
language type @objtype{gmp_randstate}.  These objects, and their internal representation, are
correctly garbage collected.
@end deftp


@menu
* random obj::                  Random number generator objects.
* random init::                 Random number generators initialisation.
* random seed::                 Random number generators seeding.
* random gen::                  Generating random numbers.
@end menu

@c page
@node random obj
@section Random number generator objects


@defun gmp-randstate
Build and return a new (@objtype{gmp-randstate} object.  The generator is @strong{uninitialised}.
@end defun


@defun gmp-randstate-p (@var{obj})
Return true if @var{obj} is an instance of @objtype{gmp-randstate}; otherwise return false.
@end defun

@c page
@node random init
@section Random number generators initialisation


@c void gmp_randinit_default (gmp_randstate_t STATE)
@deffn {Generic Function} gmp-randinit-default@strong{ (@var{STATE}})
@deffnx {Method} gmp-randinit-default ((@var{STATE} gmp-randstate))
Initialise @var{STATE} with a default algorithm.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c void gmp_randinit_mt (gmp_randstate_t STATE)
@deffn {Generic Function} gmp-randinit-mt (@var{STATE})
@deffnx {Method} gmp-randinit-mt ((@var{STATE} gmp-randstate))
Initialise @var{STATE} for a Mersenne Twister algorithm.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-mt state)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c void gmp_randinit_lc_2exp (gmp_randstate_t STATE, const mpz_t A, unsigned long C, mp_bitcnt_t M2EXP)
@deffn {Generic Function} gmp-randinit-lc-2exp (@var{STATE} @var{A} @var{C} M2EXP)
@deffnx {Method} gmp-randinit-lc-2exp ((@var{STATE} gmp-randstate) (@var{A} mpz) (@var{C} integer) (@var{M2EXP} integer))
Initialise @var{STATE} with a linear congruential algorithm.

@lisp
(let ((state  (gmp-randstate))
      (A      (mpz 19))
      (C      2)
      (M2EXP  3))
  (gmp-randinit-lc-2exp state A C M2EXP)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c int gmp-randinit-lc-2exp_size (gmp_randstate_t STATE, mp_bitcnt_t SIZE)
@deffn {Generic Function} gmp-randinit-lc-2exp-size (@var{STATE} @var{SIZE})
@deffnx {Method} gmp-randinit-lc-2exp-size ((@var{STATE} gmp-randstate) (@var{SIZE} integer))
Initialise @var{STATE} with a linear congruential algorithm.

@lisp
(let ((state  (gmp-randstate))
      (size   30))
  (gmp-randinit-lc-2exp-size state size)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c void gmp-randinit-set (gmp_randstate_t ROP, gmp_randstate_t OP)
@deffn {Generic Function} gmp-randinit-set (@var{ROP} @var{OP})
@deffnx {Method} gmp-randinit-set ((@var{ROP} gmp-randstate) (@var{OP} gmp-randstate))
Initialise @var{ROP} with a copy of the algorithm and state from @var{OP}.

@lisp
(let ((rop    (gmp-randstate))
      (op     (gmp-randstate)))
  (gmp-randinit-default op)
  (gmp-randseed-ui op 123)
  (gmp-randinit-set rop op)
  (let ((num (gmp-urandomb-ui op 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn

@c page
@node random seed
@section Random number generators seeding


@c void gmp_randseed (gmp_randstate_t STATE, const mpz_t SEED)
@deffn {Generic Function} gmp-randseed (@var{STATE} @var{SEED})
@deffnx {Method} gmp-randseed ((@var{STATE} gmp-randstate) (@var{SEED} mpz))
Set an initial seed value into @var{STATE}.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed state (mpz 123))
  (let ((num (gmp-urandomm-ui state 3)))
    (and (<= 0 num) (< num 3))))
@result{} t
@end lisp
@end deffn


@c void gmp_randseed_ui (gmp_randstate_t STATE, unsigned long int SEED)
@deffn {Generic Function} gmp-randseed-ui (@var{STATE} @var{SEED})
@deffnx {Method} gmp-randseed-ui ((@var{STATE} gmp-randstate) (@var{SEED} integer))
Set an initial seed value into @var{STATE}.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 12)
  (let ((num (gmp-urandomm-ui state 3)))
    (and (<= 0 num) (< num 3))))
@result{} t
@end lisp
@end deffn

@c page
@node random gen
@section Generating random numbers


@c unsigned long gmp_urandomb_ui (gmp_randstate_t STATE, unsigned long N)
@deffn {Generic Function} gmp-urandomb-ui (@var{state} @var{N})
@deffnx {Method} gmp-urandomb-ui ((@var{state} gmp-randstate) (@var{N} integer))
Return a uniformly distributed random number of @var{N} bits, in the range 0 to 2^@var{N}-1
inclusive.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c unsigned long gmp_urandomm_ui (gmp_randstate_t STATE, unsigned long N)
@deffn {Generic Function} gmp-urandomm-ui (@var{state} @var{N})
@deffnx {Method} gmp-urandomm-ui ((@var{state} gmp-randstate) (@var{N} integer))
Return a uniformly distributed random number in the range 0 to @var{N}-1, inclusive.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomm-ui state 3)))
    (and (<= 0 num) (< num 3))))
@result{} t
@end lisp
@end deffn

@c page
@node errors
@chapter How errors are signalled


Occasionally the functions in @value{PACKAGE} signal an error; the following error symbols are
defined.


@defvr {Error Symbol} mmux-gmp-error
The base type of all the error symbols.
@end defvr


@defvr {Error Symbol} mmux-gmp-invalid-initialisation-value
@defvrx {Parent Error Symbol} mmux-gmp-error
Used to signal an invalid initialisation value for an object constructor.
@end defvr


@defvr {Error Symbol} mmux-gmp-no-memory-error
@defvrx {Parent Error Symbol} mmux-gmp-error
Used to signal that there was not enough memory to allocate an object.
@end defvr


@defvr {Error Symbol} mmux-gmp-string-too-long
@defvrx {Parent Error Symbol} mmux-gmp-error
Used to signal that a string argument is to long to be processed.  As example, this may happen when
converting strings to and from elisp objects.
@end defvr

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

We can find @gmp{} here:

@center @url{https://gmplib.org/}

We can found informations and examples about Emacs modules at the repository mirror, under the
@file{modules} directory:

@center @url{https://github.com/emacs-mirror/emacs}

There is also a list of resources about Emacs modules:

@center @url{https://github.com/emacs-pe/emacs-modules}

If we want to compare our usage code with someone else's code we can look at this site (@aurl{} last
checked Jan 28, 2020):

@center @url{https://documentation.help/Math.Gmp.Native.NET/846f5c8a-6cba-433e-9f18-cde2ff5695cd.htm}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

