\input texinfo.tex
@c %**start of header
@setfilename mmux-emacs-gmp.info
@settitle MMUX Emacs GMP
@c %**end of header

@include version.texi
@include macros.texi
@include elisp-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX Emacs GMP

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX Emacs GMP

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-emacs-gmp

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2020

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_EMACS_GMP
@set PackagePkgconfigModule             @code{mmux-emacs-gmp}
@set PackageLibsVar                     @env{MMUX_EMACS_GMP_LIBS}
@set PackageCflagsVar                   @env{MMUX_EMACS_GMP_CFLAGS}

@set PackageLibstem                     @file{mmux-emacs-gmp}
@set PackageSharedLibraryBasename       @file{libmmux-emacs-gmp}

@set PackageEmacsModule                 @file{mmux-emacs-gmp}
@set PackageHeader                      mmux-emacs-gmp.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set PackageApiCPrefixLower             mmux_emacs_gmp_
@set PackageApiCPrefixUpper             MMUX_EMACS_GMP_
@set PackageApiElispPrefix              mmux-gmp-

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set GMPversion                 6.2.0+

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro gmpref{NODE, TITLE}
@xref{\NODE\,\TITLE\,\TITLE\,gmp}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a @gnu{} Emacs module
implemented on top of a C11 language library, providing an interface to the @gmp{} library.

The library supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
26+ and @gmp{} version @value{GMPversion}.  This package depends upon the external packages:
@samp{cl-lib}.  To run the test suite: this package requires the ERT package.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-emacs-gmp: (mmux-emacs-gmp).       MMUX Emacs GMP, an interface to GMP.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* integers::                    Exact integer objects and operations.
* rationals::                   Rational number objects and operations.
* floats::                      Floating-point number objects and operations.
* random::                      Random numbers generation.
* errors::                      How errors are signalled.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* modules: (elisp)Writing Dynamic Modules.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a @gnu{} Emacs module
implemented on top of a C11 language library, providing an interface to the @gmp{} library.

The library supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
26+ and @gmp{} version @value{GMPversion}.  This package depends upon the external packages:
@samp{cl-lib}.  To run the test suite: this package requires the ERT package.

@value{PACKAGE} installs a single elisp module @value{PackageEmacsModule} and a C language shared
library with basename @value{PackageSharedLibraryBasename} (using the @gnu{} Libtool
infrastructure).  All the elisp definition names are prefixed with either
@code{@value{PackageApiElispPrefix}}, @samp{mpz-}, @samp{mpq-} or @samp{mpf-}.  The C language
shared library is installed under @samp{$libdir}, for example:

@center @file{/usr/local/lib64}

@noindent
while the elisp module goes under @samp{$lispdir}, for example:

@center @file{/usr/local/share/emacs/site-lisp}

@noindent
so to load the module (under an Emacs installation with dynamic modules enabled) we should do
something like:

@lisp
(add-to-list 'load-path "/usr/local/lib64"
                        "/usr/local/share/emacs/site-lisp")
(require 'mmux-emacs-gmp)
@end lisp

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
It might be possible that we want to write a C language library making use of the facilities of this
package; so @value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the C
language function names in the @api{} are prefixed with @code{@value{PackageApiCPrefixLower}}; all
the C language preprocessor symbol names are prefixed with @code{@value{PackageApiCPrefixUpper}};
all the type names are prefixed with @code{@value{PackageApiCPrefixLower}} and suffixed with
@code{_t}.

Most of the functions implemented by @gmp{} are wrapped by @value{PACKAGE}, with the exclusion of
the initialisation functions and some other functions.  The elisp function names are equal to the C
language function names, with each underscore turned into a dash; so @cfunc{mpz_get_str} becomes
@func{mpz-get-str}.  Only a brief description of the arguments is given in this document: for the
full meaning of the function arguments we should refer to the original @gmp{} documentation.

@menu
* overview linking::            Linking code with the library.
@end menu

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@defun mmux-gmp-version-string
Return a string representing the interface version number.
@end defun


@defun mmux-gmp-version-interface-current
Return an integer representing the library interface current number.
@end defun


@defun mmux-gmp-version-interface-revision
Return an integer representing the library interface current revision number.
@end defun


@defun mmux-gmp-version-interface-age
Return an integer representing the library interface current age.
@end defun


@deftypefun {char const *} mmux_emacs_gmp_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_emacs_gmp_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_emacs_gmp_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_emacs_gmp_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node integers
@chapter Exact integer objects and operations


@deftp {Object Type} mpz
Type of structures representing a multiple precision exact integer.  It is a wrapper for the C
language type @objtype{mpz_t}.  These objects, and their internal representation, are correctly
garbage collected.
@end deftp


@menu
* integers allocation::         Allocating exact integers.
* integers predicates::         Exact integer predicates.
* integers assignment::         Assigning values to objects.
* integers conversion::         Converting exact integers to
                                other objects.
* integers arithmetic::         Arithmetic operations.
* integers division::           Division operations.
* integers exponentiation::     Exponentiation operations.
* integers roots::              Root extraction functions.
* integers comparison::         Commparison functions.
* integers theoretic::          Number theoretic functions.
* integers bitlogic::           Logical and bit manipulation functions.
* integers random::             Random number functions.
* integers miscellaneous::      Miscellaneous functions.
@end menu

@c page
@node integers allocation
@section Allocating exact integers


@defun mpz &optional @var{INIT}
Build and return a new @objtype{mpz} object instance.  When called with no arguments: the object is
uninitialised.

When the @var{INIT} argument is provided: it must be an initialisation value for the @objtype{mpz}
object.  I can be: an exact integer number; a floating--point number; an @objtype{mpz} object; an
@objtype{mpq} object; an @objtype{mpf} object.

When the @var{INIT} argument is missing: the returned object is initialised to zero.
@end defun

@c page
@node integers predicates
@section Exact integer predicates


@defun mpz-p @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{mpz}; otherwise return @false{}.

@lisp
(mpz-p (mpz))   @result{} t
(mpz-p 123)     @result{} nil
@end lisp
@end defun

@c page
@node integers assignment
@section Assigning values to objects


@defun mpz-set @var{rop} @var{op}
Assign the value of @var{op} to @var{rop}; both the operands must be of type @objtype{mpz}.

@lisp
(defconst rop (mpz))
(defconst op  (mpz))

(mpz-set-si rop 123)
(mpz-set    op rop)
(mpz-get-str 10 op)     @result{} "123"
@end lisp
@end defun


@defun mpz-set-si @var{rop} @var{int}
Assign the value of an exact integer object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))

(mpz-set-si rop 123)
(mpz-get-str 10 op)     @result{} "123"
@end lisp
@end defun


@defun mpz-set-d @var{rop} @var{flo}
Assign the value of a floating--point object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))

(mpz-set-d rop 12.3)
(mpz-get-str 10 rop)    @result{} "12"
@end lisp
@end defun


@defun mpz-set-q @var{rop} @var{op}
Assign the value of an @objtype{mpq} object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))
(defconst op  (mpq))

(mpq-set-si op 10 7)
(mpz-set-q rop op)
(mpz-get-str 10 rop)    @result{} "1"
@end lisp
@end defun


@defun mpz-set-f @var{rop} @var{op}
Assign the value of an @objtype{mpf} object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))
(defconst op  (mpf))

(mpf-set-d op 12.34)
(mpz-set-f rop op)
(mpz-get-str 10 rop)    @result{} "12"
@end lisp
@end defun


@defun mpz-set-str @var{rop} @var{str} @var{base}
Assign the value of a string object to an @objtype{mpz} object.  The argument @var{base} must be an
exact integer representing the base of the numeric string representation: @math{0} or a value
between @math{2} and @math{32}.

@lisp
(defconst rop (mpz))

(mpz-set-str rop "123" 10)
(mpz-get-str 10 rop)    @result{} "123"
@end lisp
@end defun


@defun mpz-swap @vari{op} @varii{op}
Swap the values between two @objtype{mpz} objects.

@lisp
(defconst op1 (mpz))
(defconst op2 (mpz))

(mpz-set-si op1 123)
(mpz-set-si op2 456)
(mpz-swap op1 op2)
(mpz-get-str 10 op1)  @result{} "456"
(mpz-get-str 10 op2)  @result{} "123"
@end lisp
@end defun

@c page
@node integers conversion
@section Converting exact integers to other objects


@defun mpz-get-ui @var{op}
Convert an object @var{op} of type @objtype{mpz} to an unsigned exact integer number.

@lisp
(mpz-get-ui (mpz 123))  @result{} 123
@end lisp
@end defun


@defun mpz-get-si @var{op}
Convert an object @var{op} of type @objtype{mpz} to an signed exact integer number.

@lisp
(mpz-get-si (mpz 123))  @result{} 123
@end lisp
@end defun


@defun mpz-get-d @var{op}
Convert an object @var{op} of type @objtype{mpz} to a floating--point number.

@lisp
(mpz-get-d (mpz 123))  @result{} 123.0
@end lisp
@end defun


@defun mpz-get-d-2exp @var{op}
Convert an object @var{op} of type @objtype{mpz} to a floating--point number, yielding the exponent
separately.  The return value is a pair whose car is a floating--point number and whose cdr is the
exponent:

@lisp
(defconst rv (mpz-get-d-2exp (mpz 123)))

rv                                      @result{} (0.9609375 . 7)
(* (car rv) (expt 2 (cdr rv)))          @result{} 123.0
@end lisp
@end defun


@defun mpz-get-str @var{base} @var{op}
Convert an object @var{op} of type @objtype{mpz} to a string; return the resulting string.
@var{base} must be an exact integer representing the base of the numeric string representation:
positive between @math{2} and @math{36} or negative between @math{-2} and @math{-36}.

@lisp
(defconst op (mpz))
(mpz-set-si op 15)
(mpz-get-str  10 op)    @result{} "15"
(mpz-get-str  16 op)    @result{} "f"
(mpz-get-str -16 op)    @result{} "F"
@end lisp
@end defun

@c page
@node integers arithmetic
@section Arithmetic operations


@defun mpz-add @var{rop} @vari{op} @varii{op}
Add two @objtype{mpz} objects.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 10))
      (op2      (mpz 1)))
  (mpz-add rop op1 op2)
  (mpz-get-ui rop))
@result{} 11
@end lisp
@end defun


@defun mpz-add-ui @var{rop} @vari{op} @varii{op}
Add an @objtype{mpz} object to an unsigned exact integer number.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 10))
      (op2      1))
  (mpz-add-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} 11
@end lisp
@end defun


@defun mpz-sub @var{rop} @vari{op} @varii{op}
Subtract two @objtype{mpz} objects.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 11))
      (op2      (mpz 1)))
  (mpz-sub rop op1 op2)
  (mpz-get-ui rop))
@result{} 10
@end lisp
@end defun


@defun mpz-sub-ui @var{rop} @vari{op} @varii{op}
Subtract an unsigned exact integer number from an @objtype{mpz} object.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 11))
      (op2      1))
  (mpz-sub-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} 10
@end lisp
@end defun


@defun mpz-addmul @var{rop} @vari{op} @varii{op}
Multiply two @objtype{mpz} objects, then add the result to another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     (mpz 2)))
  (mpz-addmul rop op1 op2)
  (mpz-get-ui rop))
@result{} (+ 100 (* 11 2))
@end lisp
@end defun


@defun mpz-addmul-ui @var{rop} @vari{op} @varii{op}
Multiply an @objtype{mpz} object with an unsigned exact integer number, then add the result to
another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     2))
  (mpz-addmul-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} (+ 100 (* 11 2))
@end lisp
@end defun


@defun mpz-submul @var{rop} @vari{op} @varii{op}
Multiply two @objtype{mpz} objects, then subtract the result from another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     (mpz 2)))
  (mpz-submul rop op1 op2)
  (mpz-get-ui rop))
@result{} (- 100 (* 11 2))
@end lisp
@end defun


@defun mpz-submul-ui @var{rop} @vari{op} @varii{op}
Multiply an @objtype{mpz} object with an unsigned exact integer number, then subtract the result
from another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     2))
  (mpz-submul-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} (- 100 (* 11 2))
@end lisp
@end defun


@defun mpz-mul @var{rop} @vari{op} @varii{op}
Multiply two @objtype{mpz} objects.

@lisp
(let ((rop     (mpz))
      (op1     (mpz 111))
      (op2     (mpz 2)))
  (mpz-mul rop op1 op2)
  (mpz-get-ui rop))
@result{} 222
@end lisp
@end defun


@defun mpz-mul-si @var{rop} @vari{op} @varii{op}
Multiply an @objtype{mpz} object by a signed exact integer number.

@lisp
(let ((rop     (mpz))
      (op1     (mpz 111))
      (op2     2))
  (mpz-mul-si rop op1 op2)
  (mpz-get-ui rop))
@result{} 222
@end lisp
@end defun


@defun mpz-mul-ui @var{rop} @vari{op} @varii{op}
Multiply an @objtype{mpz} object by an unsigned exact integer number.

@lisp
(let ((rop     (mpz))
      (op1     (mpz 111))
      (op2     2))
  (mpz-mul-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} 222
@end lisp
@end defun


@defun mpz-mul-2exp @var{rop} @var{op} @var{bitcnt}
Left shift an @objtype{mpz} object.

@lisp
(let ((rop     (mpz))
      (op      (mpz #b10101))
      (bitcnt  2))
  (mpz-mul-2exp rop op bitcnt)
  (mpz-get-ui rop))
@result{} #b1010100
@end lisp
@end defun


@defun mpz-neg @var{rop} @var{op}
Negate an @objtype{mpz} object.

@lisp
(let ((rop     (mpz))
      (op      (mpz 123)))
  (mpz-neg rop op)
  (mpz-get-si rop))
@result{} -123
@end lisp
@end defun


@defun mpz-abs @var{rop} @var{op}
Compute the absolute value of an @objtype{mpz} object.

@lisp
(let ((rop     (mpz))
      (op      (mpz -123)))
  (mpz-abs rop op)
  (mpz-get-ui rop))
@result{} 123
@end lisp
@end defun

@c page
@node integers division
@section Division operations


The division functions divide numerator @math{N} by the denominator @math{D}, forming a quotient
@math{Q} and/or remainder @math{R}; for the @code{2exp} functions, @math{D=2^B} where @math{B} is
the bit count.  The rounding is in three styles, each suiting different applications.

@table @code
@item cdiv
Rounds @math{Q} up towards +infinity, and @math{R} will have the opposite sign to @math{D}.  The
@code{c} stands for ``ceil''.

@item fdiv
Rounds @math{Q} down towards -infinity, and @math{R} will have the same sign as @math{D}.  The @code{f}
stands for ``floor''.

@item tdiv
Rounds @math{Q} towards zero, and @math{R} will have the same sign as @math{N}.  The @code{t} stands
for ``truncate''.
@end table

In all cases @math{Q} and @math{R} will satisfy @math{N = Q * D + R}, and @math{R} will satisfy
@math{0 <= abs(R) < abs(D)}.

@menu
* integers division ceil::      Rounding towards +infinity (ceil).
* integers division floor::     Rounding towards -infinity (floor).
* integers division truncate::  Rounding towards zero (truncate).
* integers division modulo::    Modulo functions.
* integers division exact::     Exact division.
@end menu

@c page
@node integers division ceil
@subsection Rounding towards +infinity (ceil)


For the examples in this section, remember that the template operation is:

@example
N = Q * D + R
@end example

@noindent
and with ceil rounding we have:

@example
N = 10
D = 3
Q = ceil(N/D) = ceil(10 / 3) = ceil(3.33333) = 4
R = N - Q * D = 10 - 4 * 3 = -2
@end example

@noindent
for the @code{2exp} functions:

@example
N = 10
B = 3
D = 2^B = 2^3 = 8
Q = ceil(N/D) = ceil(10 / 8) = ceil(1.25) = 2
R = N - Q * D = 10 - 2 * 8 = 10 - 16 = -6
@end example


@defun mpz-cdiv-q @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-cdiv-q Q N D)
  (mpz-get-si Q))
@result{} 4
@end lisp
@end defun


@defun mpz-cdiv-r @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-cdiv-r R N D)
  (mpz-get-si R))
@result{} -2
@end lisp
@end defun


@defun mpz-cdiv-qr @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
  (let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-cdiv-qr Q R N D)
  (mpz-get-si Q)        @result{} +4
  (mpz-get-si R))       @result{} -2
@end lisp
@end defun


@defun mpz-cdiv-q-ui @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-cdiv-q-ui Q N D)))
    (mpz-get-si Q)      @result{} +4
    absR))              @result{} +2
@end lisp
@end defun


@defun mpz-cdiv-r-ui @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-cdiv-r-ui R N D)))
    (mpz-get-si R)      @result{} -2
    absR))              @result{} +2
@end lisp
@end defun


@defun mpz-cdiv-qr-ui @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-cdiv-qr-ui Q R N D)))
    (mpz-get-si Q)      @result{} +4
    (mpz-get-si R)      @result{} -2
    absR))              @result{} +2
@end lisp
@end defun


@defun mpz-cdiv-ui @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((N      (mpz 10))
      (D      3))
  (mpz-cdiv-ui N D))    @result{} +2
@end lisp
@end defun


@defun mpz-cdiv-q-2exp @var{Q} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-cdiv-q-2exp Q N B)
  (mpz-get-si Q))
@result{} +2
@end lisp
@end defun


@defun mpz-cdiv-r-2exp @var{R} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-cdiv-r-2exp R N B)
  (mpz-get-si R))
@result{} -6
@end lisp
@end defun

@c page
@node integers division floor
@subsection Rounding towards -infinity (floor)


For the examples in this section, the template operation is:

@example
N = Q * D + R
@end example

@noindent
and with floor rounding we have:

@example
N = 10
D = 3
Q = floor(N/D) = floor(10 / 3) = floor(3.33333) = 3
R = N - Q * D = 10 - 3 * 3 = +1
@end example

@noindent
for the @code{2exp} functions:

@example
N = 10
B = 3
D = 2^B = 2^3 = 8
Q = floor(N/D) = floor(10 / 8) = floor(1.25) = 1
R = N - Q * D = 10 - 1 * 8 = 10 - 8 = +2
@end example


@defun mpz-fdiv-q @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-fdiv-q Q N D)
  (mpz-get-si Q))
@result{} +3
@end lisp
@end defun


@defun mpz-fdiv-r @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-fdiv-r R N D)
  (mpz-get-si R))
@result{} +1
@end lisp
@end defun


@defun mpz-fdiv-qr @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-fdiv-qr Q R N D)
  (mpz-get-si Q)        @result{} +3
  (mpz-get-si R))       @result{} +1
@end lisp
@end defun


@defun mpz-fdiv-q-ui @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-fdiv-q-ui Q N D)))
    (mpz-get-si Q)      @result{} +3
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-fdiv-r-ui @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-fdiv-r-ui R N D)))
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-fdiv-qr-ui @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-fdiv-qr-ui Q R N D)))
    (mpz-get-si Q)      @result{} +3
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-fdiv-ui @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((N      (mpz 10))
      (D      3))
  (mpz-fdiv-ui N D))
@result{} +1
@end lisp
@end defun


@defun mpz-fdiv-q-2exp @var{Q} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-fdiv-q-2exp Q N B)
  (mpz-get-si Q))
@result{} +1
@end lisp
@end defun


@defun mpz-fdiv-r-2exp @var{R} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-fdiv-r-2exp R N B)
  (mpz-get-si R))
@result{} +2
@end lisp
@end defun

@c page
@node integers division truncate
@subsection Rounding towards zero (truncate)


For the examples in this section, the template operation is:

@example
N = Q * D + R
@end example

@noindent
and with truncate rounding we have:

@example
N = 10
D = 3
Q = truncate(N/D) = truncate(10 / 3) = truncate(3.33333) = 3
R = N - Q * D = 10 - 3 * 3 = +1
@end example

@noindent
for the @code{2exp} functions:

@example
N = 10
B = 3
D = 2^B = 2^3 = 8
Q = truncate(N/D) = truncate(10 / 8) = truncate(1.25) = 1
R = N - Q * D = 10 - 1 * 8 = 10 - 8 = +2
@end example


@defun mpz-tdiv-q @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-tdiv-q Q N D)
  (mpz-get-si Q))
@result{} +3
@end lisp
@end defun


@defun mpz-tdiv-r @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-tdiv-r R N D)
  (mpz-get-si R))
@result{} +1
@end lisp
@end defun


@defun mpz-tdiv-qr @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-tdiv-qr Q R N D)
  (mpz-get-si Q)        @result{} +3
  (mpz-get-si R))       @result{} +1
@end lisp
@end defun


@defun mpz-tdiv-q-ui @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-tdiv-q-ui Q N D)))
    (mpz-get-si Q)      @result{} +3
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-tdiv-r-ui @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-tdiv-r-ui R N D)))
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-tdiv-qr-ui @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-tdiv-qr-ui Q R N D)))
    (mpz-get-si Q)      @result{} +3
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-tdiv-ui @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((N      (mpz 10))
      (D      3))
  (mpz-tdiv-ui N D))
@result{} +1
@end lisp
@end defun


@defun mpz-tdiv-q-2exp @var{Q} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-tdiv-q-2exp Q N B)
  (mpz-get-si Q))
@result{} +1
@end lisp
@end defun


@defun mpz-tdiv-r-2exp @var{R} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-tdiv-r-2exp R N B)
  (mpz-get-si R))
@result{} +2
@end lisp
@end defun

@c page
@node integers division modulo
@subsection Modulo functions


The following functions use floor rounding, @ref{integers division floor, Rounding towards -infinity
(floor)}.


@defun mpz-mod @var{R} @var{N} @var{D}
Set @var{R} to @var{N} mod @var{D}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-mod R N D)
  (mpz-get-si R))
@result{} 1
@end lisp
@end defun


@defun mpz-mod-ui @var{R} @var{N} @var{D}
Set @var{R} to @var{N} mod @var{D}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (mpz-mod-ui R N D))
@result{} 1
@end lisp
@end defun

@c page
@node integers division exact
@subsection Exact division


The following functions will return correct results only when @math{D} is an exact divisor of
@math{N}.


@defun mpz-divexact @var{Q} @var{N} @var{D}
Set @var{Q} to @var{N}/@var{D}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 9))
      (D      (mpz 3)))
  (mpz-divexact Q N D)
  (mpz-get-si Q))
@result{} 3
@end lisp
@end defun


@defun mpz-divexact-ui @var{Q} @var{N} @var{D}
Set @var{Q} to @var{N}/@var{D}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 9))
      (D      3))
  (mpz-divexact-ui Q N D)
  (mpz-get-si Q))
@result{} 3
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Exact division tests


@defun mpz-divisible-p @var{N} @var{D}
Return true if @var{N} is exactly divisible by @var{D}.

@lisp
(let ((N      (mpz 9))
      (D      (mpz 3)))
  (mpz-divisible-p N D))
@result{} t
@end lisp
@end defun


@defun mpz-divisible-ui-p @var{N} @var{D}
Return true if @var{N} is exactly divisible by @var{D}.

@lisp
(let ((N      (mpz 9))
      (D      3))
  (mpz-divisible-ui-p N D))
@result{} t
@end lisp
@end defun


@defun mpz-divisible-2exp-p @var{N} @var{B}
Return true if @var{N} is exactly divisible by 2^@var{B}.

@lisp
(let ((N      (mpz 16))
      (B      3))
  (mpz-divisible-2exp-p N B))
@result{} t
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Congruency tests


@math{N} is congruent to @math{C} modulo @math{D} if there exists an integer @math{Q} satisfying
@math{N = C + Q * D}.


@defun mpz-congruent-p @var{N} @var{C} @var{D}
Return non-zero if @var{N} is congruent to @var{C} modulo @var{D}.

@lisp
(let ((N      (mpz 7))
      (C      (mpz 1))
      (D      (mpz 3)))
  (mpz-congruent-p N C D))
@result{} t
@end lisp
@end defun


@defun mpz-congruent-ui-p @var{N} @var{C} @var{D}
Return non-zero if @var{N} is congruent to @var{C} modulo @var{D}.

@lisp
(let ((N      (mpz 7))
      (C      1)
      (D      3))
  (mpz-congruent-ui-p N C D))
@result{} t
@end lisp
@end defun


@defun mpz-congruent-2exp-p @var{N} @var{C} @var{B}
Return non-zero if @var{N} is congruent to @var{C} modulo 2^@var{B}.

@lisp
(let ((N      (mpz 17))
      (C      (mpz 1))
      (B      3))
  (mpz-congruent-2exp-p N C B))
@result{} t
@end lisp
@end defun

@c page
@node integers exponentiation
@section Exponentiation operations


@defun mpz-powm @var{ROP} @var{BASE} @var{EXP} @var{MOD}
Set @var{ROP} to (@var{BASE} raised to @var{EXP}) modulo @var{MOD}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    (mpz 3))
      (mod    (mpz 2)))
  (mpz-powm rop base exp mod)
  (equal (mod (expt 5 3) 2)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun


@defun mpz-powm-ui @var{ROP} @var{BASE} @var{EXP} @var{MOD}
Set @var{ROP} to (@var{BASE} raised to @var{EXP}) modulo @var{MOD}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    3)
      (mod    (mpz 2)))
  (mpz-powm-ui rop base exp mod)
  (equal (mod (expt 5 3) 2)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun


@defun mpz-powm-sec @var{ROP} @var{BASE} @var{EXP} @var{MOD}
Set @var{ROP} to (@var{BASE} raised to @var{EXP}) modulo @var{MOD}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    (mpz 3))
      (mod    (mpz 7)))
  (mpz-powm-sec rop base exp mod)
  (equal (mod (expt 5 3) 2)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun


@defun mpz-pow-ui @var{ROP} @var{BASE} @var{EXP}
Set @var{ROP} to @var{BASE} raised to @var{EXP}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    3))
  (mpz-pow-ui rop base exp)
  (equal (expt 5 3)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun


@defun mpz-ui-pow-ui @var{ROP} @var{BASE} @var{EXP}
Set @var{ROP} to @var{BASE} raised to @var{EXP}.

@lisp
(let ((rop    (mpz))
      (base   5)
      (exp    3))
  (mpz-ui-pow-ui rop base exp)
  (equal (expt 5 3)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun

@c page
@node integers roots
@section Root extraction functions


@deffn {Generic Function} mpz-root (@var{rop} @var{op} @var{N})
@deffnx {Method} mpz-root ((@var{rop} mpz) (@var{op} mpz) (@var{N} integer))
Set @var{ROP} to the truncated integer part of the @var{N}th root of @var{OP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz 8))
      (N      3))
  (mpz-root rop op N)
  (mpz-get-si rop))
@result{} 2
@end lisp
@end deffn


@deffn {Generic Function} mpz-rootrem (@var{root} @var{rem} @var{U} @var{N})
@deffnx {Method} mpz-rootrem ((@var{root} mpz) (@var{rem} mpz) (@var{U} mpz) (@var{N} integer))
Set @var{ROOT} to the truncated integer part of the @var{N}th root of @var{U}.  Set @var{REM} to the
remainder, @var{U}-@var{ROOT}^@var{N}.

@lisp
;; 9 = 2^3 + 1
(let ((rop    (mpz))
      (rem    (mpz))
      (op     (mpz 9))
      (N      3))
  (mpz-rootrem rop rem op N)
  (mpz-get-si rop)      @result{} 2
  (mpz-get-si rem))     @result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-sqrt (@var{rop} @var{op})
@deffnx {Method} mpz-sqrt ((@var{rop} mpz) (@var{op} mpz))
Set @var{ROP} to the truncated integer part of the square root of @var{OP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz 16)))
  (mpz-sqrt rop op)
  (mpz-get-si rop))
@result{} 4
@end lisp
@end deffn


@deffn {Generic Function} mpz-sqrtrem (@vari{rop} @varii{rop} @var{op})
@deffnx {Method} mpz-sqrtrem ((@vari{rop} mpz) (@var{rop} mpz) (@var{op} mpz))
Set @vari{ROP} to the truncated integer part of the square root of @var{OP}.  Set @varii{ROP} to the
remainder @var{OP}-@vari{ROP}*@vari{ROP}.

@lisp
;; 17 = 4^2 + 1
(let ((rop    (mpz))
      (rem    (mpz))
      (op     (mpz 17)))
  (mpz-sqrtrem rop rem op)
  (mpz-get-si rop)      @result{} 4
  (mpz-get-si rem))     @result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-perfect-power-p (@var{op})
@deffnx {Method} mpz-perfect-power-p ((@var{op} mpz))
Return true if @var{OP} is a perfect power; otherwise return false.

@lisp
(mpz-perfect-power-p (mpz 8))           @result{} t
(mpz-perfect-power-p (mpz 7))           @result{} nil
@end lisp
@end deffn


@deffn {Generic Function} mpz-perfect-square-p (@var{op})
@deffnx {Method} mpz-perfect-square-p ((@var{op} mpz))
Return true if @var{OP} is a perfect square; otherwise return false.

@lisp
(mpz-perfect-square-p (mpz 16))         @result{} t
(mpz-perfect-square-p (mpz 7))          @result{} nil
@end lisp
@end deffn

@c page
@node integers comparison
@section Commparison functions


@deffn {Generic Function} mpz-cmp (@vari{op} @varii{op})
@deffnx {Method} mpz-cmp ((@vari{op} mpz) (@varii{op} mpz))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp (mpz 1) (mpz 2))       @result{} -1
(mpz-cmp (mpz 0) (mpz 0))       @result{} 0
(mpz-cmp (mpz 2) (mpz 1))       @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmp-d (@vari{op} @varii{op})
@deffnx {Method} mpz-cmp-d ((@vari{op} mpz) (@varii{op} float))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp-d (mpz 1) 2.0))        @result{} -1
(mpz-cmp-d (mpz 0) 0.0))        @result{} 0
(mpz-cmp-d (mpz 2) 1.0))        @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmp-si (@vari{op} @varii{op})
@deffnx {Method} mpz-cmp-si ((@vari{op} mpz) (@varii{op} integer))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp-si (mpz -2) -1))       @result{} -1
(mpz-cmp-si (mpz  0)  0))       @result{} 0
(mpz-cmp-si (mpz -1) -2))       @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmp-ui (@vari{op} @varii{op})
@deffnx {Method} mpz-cmp-ui ((@vari{op} mpz) (@varii{op} integer))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp-ui (mpz 1) 2))         @result{} -1
(mpz-cmp-ui (mpz 0) 0))         @result{} 0
(mpz-cmp-ui (mpz 2) 1))         @result{} +1
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-cmpabs (@vari{op} @varii{op})
@deffnx {Method} mpz-cmpabs ((@vari{op} mpz) (@varii{op} mpz))
Compare the absolute values of OP1 and OP2.

@lisp
(mpz-cmpabs (mpz 1) (mpz -2))   @result{} -1
(mpz-cmpabs (mpz 0) (mpz  0))   @result{} 0
(mpz-cmpabs (mpz 2) (mpz  1))   @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmpabs-d (@vari{op} @varii{op})
@deffnx {Method} mpz-cmpabs-d ((@vari{op} mpz) (@varii{op} float))
Compare the absolute values of OP1 and OP2.

@lisp
(mpz-cmpabs-d (mpz 1) -2.0)     @result{} -1
(mpz-cmpabs-d (mpz 0)  0.0)     @result{} 0
(mpz-cmpabs-d (mpz 2)  1.0)     @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmpabs-ui (@vari{op} @varii{op})
@deffnx {Method} mpz-cmpabs-ui ((@vari{op} mpz) (@varii{op} integer))
Compare the absolute values of OP1 and OP2.

@lisp
(mpz-cmpabs-ui (mpz  1) 2)      @result{} -1
(mpz-cmpabs-ui (mpz  0) 0)      @result{} 0
(mpz-cmpabs-ui (mpz -2) 1)      @result{} +1
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-sgn (@var{op})
@deffnx {Method} mpz-sgn ((@var{op} mpz))
Return an integer representing the sign of the operand.

@lisp
(mpz-sgn (mpz +1))      @result{} +1
(mpz-sgn (mpz  0))      @result{} 0
(mpz-sgn (mpz -1))      @result{} -1
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-zero-p (@var{OP})
@deffnx {Method} mpz-zero-p ((@var{OP} mpz))
Return true if @var{OP} is zero; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-non-zero-p (@var{OP})
@deffnx {Method} mpz-non-zero-p ((@var{OP} mpz))
Return true if @var{OP} is non-zero; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-positive-p (@var{OP})
@deffnx {Method} mpz-positive-p ((@var{OP} mpz))
Return true if @var{OP} is strictly positive; otherwise return false.
@end deffn

@deffn {Generic Function} mpz-negative-p (@var{OP})
@deffnx {Method} mpz-negative-p ((@var{OP} mpz))
Return true if @var{OP} is strictly negative; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-non-positive-p (@var{OP})
@deffnx {Method} mpz-non-positive-p ((@var{OP} mpz))
Return true if @var{OP} is non-positive; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-non-negative-p (@var{OP})
@deffnx {Method} mpz-non-negative-p ((@var{OP} mpz))
Return true if @var{OP} is non-negative; otherwise return false.
@end deffn

@c page
@node integers theoretic
@section Number theoretic functions


@deffn {Generic Function} mpz-probab-prime-p (@var{N} @var{REPS})
@deffnx {Method} mpz-probab-prime-p ((@var{N} mpz) (@var{REPS} integer))
Determine whether @var{N} is prime.

@lisp
(mpz-probab-prime-p (mpz 3) 2)
@result{} 2
@end lisp
@end deffn


@deffn {Generic Function} mpz-nextprime (@var{ROP} @var{OP})
@deffnx {Method} mpz-nextprime ((@var{ROP} mpz) (@var{OP} mpz))
Set @var{ROP} to the next prime greater than @var{OP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz 5)))
  (mpz-nextprime rop op)
  (mpz-get-si rop))
@result{} 7a
@end lisp
@end deffn


@deffn {Generic Function} mpz-gcd (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-gcd ((@var{ROP} mpz) (@var{OP1} mpz) (@var{OP2} mpz))
Set @var{ROP} to the greatest common divisor of @var{OP1} and @var{OP2}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz 10))
      (op2    (mpz 12)))
  (mpz-gcd rop op1 op2)
  (mpz-get-si rop))
@result{} 2
@end lisp
@end deffn


@deffn {Generic Function} mpz-gcd-ui (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-gcd-ui ((@var{ROP} mpz) (@var{OP1} mpz) (@var{OP2} integer))
Set @var{ROP} to the greatest common divisor of @var{OP1} and @var{OP2}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz 10))
      (op2    12))
  (let ((rop1 (mpz-gcd-ui rop op1 op2)))
    (mpz-get-si rop)    @result{} 2
    rop1))              @result{} 2
@end lisp
@end deffn


@deffn {Generic Function} mpz-gcdext (@var{G} @var{S} @var{T} @var{A} @var{B})
@deffnx {Method} mpz-gcdext ((G mpz) (S mpz) (T mpz) (A mpz) (B mpz))
Set @var{G} to the greatest common divisor of @var{A} and @var{B}, and in addition set @var{S} and
@var{T} to coefficients satisfying @var{A}*@var{S} + @var{B}*@var{T} = @var{G}.

@lisp
;; A * S + B * T = G -> 110 * 3 + 82 * (-4) = 2
(let ((G      (mpz))
      (S      (mpz))
      (T      (mpz))
      (A      (mpz 110))
      (B      (mpz 82)))
  (mpz-gcdext G S T A B)
  (mpz-get-si G)        @result{} +2
  (mpz-get-si S)        @result{} +3
  (mpz-get-si T))       @result{} -4
@end lisp
@end deffn


@deffn {Generic Function} mpz-lcm (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-@var{LCM} ((rop mpz) (@var{OP1} mpz) (@var{OP2} mpz))
Set @var{ROP} to the least common multiple of @var{OP1} and @var{OP2}.

@lisp
;;(* 2 7 5) => 70
(let ((rop    (mpz))
      (op1    (mpz (* 2 5)))
      (op2    (mpz (* 2 7))))
  (mpz-lcm rop op1 op2)
  (mpz-get-si rop))
@result{} 70
@end lisp
@end deffn


@deffn {Generic Function} mpz-lcm-ui (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-lcm-ui ((@var{ROP} mpz) (@var{OP1} mpz) (@var{OP2} integer))
Set @var{ROP} to the least common multiple of @var{OP1} and @var{OP2}.

@lisp
;;(* 2 7 5) => 70
(let ((rop    (mpz))
      (op1    (mpz (* 2 5)))
      (op2    (* 2 7)))
  (mpz-lcm-ui rop op1 op2)
  (mpz-get-si rop))
@result{} 70
@end lisp
@end deffn


@deffn {Generic Function} mpz-invert (@var{ROP} @var{OP1} @var{OP2})
@deffnx {Method} mpz-invert ((@var{ROP} mpz) (@var{OP1} mpz) (@var{OP2} mpz))
Compute the inverse of @var{OP1} modulo @var{OP2} and put the result in @var{ROP}.  See:

@center @url{https://en.wikipedia.org/wiki/Modular_multiplicative_inverse}

@lisp
;;OP2 divides (evenly) the quantity ROP * OP1 - 1
;;
;; ROP * OP1 = X * OP2 + 1
;; 4 * 3 = 1 * 11 + 1
;;
(let ((rop    (mpz))
      (op1    (mpz 3))
      (op2    (mpz 11)))
  (let ((rv (mpz-invert rop op1 op2)))
    rv                  @result{} t
    (mpz-get-si rop)))  @result{} 4
@end lisp
@end deffn


@deffn {Generic Function} mpz-jacobi (@var{A} @var{B})
@deffnx {Method} mpz-jacobi ((@var{A} mpz) (@var{B} mpz))
Calculate the Jacobi symbol (@var{A}/@var{B}).  This is defined only for @var{B} odd.

@lisp
(let ((A      (mpz 11))
      (B      (mpz 9)))
  (mpz-jacobi A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-legendre (@var{A} @var{B})
@deffnx {Method} mpz-legendre ((@var{A} mpz) (@var{B} mpz))
Calculate the Legendre symbol (@var{A}/@var{P}).

@lisp
(let ((A      (mpz 20))
      (P      (mpz 11)))
  (mpz-legendre A P))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-kronecker (@var{A} @var{B})
@deffnx {Method} mpz-kronecker ((@var{A} mpz) (@var{B} mpz))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(@var{2}/A)
when a odd, or (@var{A}/2)=0 @var{WHEN} a even.

@lisp
(let ((A      (mpz 15))
      (B      (mpz 4)))
  (mpz-kronecker A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-kronecker-si (@var{A} @var{B})
@deffnx {Method} mpz-kronecker-si ((@var{A} mpz) (@var{B} integer))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(2/@var{A})
when @var{A} odd, or (@var{A}/2)=0 when a even.

@lisp
(let ((A      (mpz 15))
      (B      4))
  (mpz-kronecker-si A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-kronecker-ui (@var{A} @var{B})
@deffnx {Method} mpz-kronecker-ui ((@var{A} mpz) (@var{B} integer))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(2/@var{A})
when @var{A} odd, or (@var{A}/2)=0 when a even.

@lisp
(let ((A      (mpz 15))
      (B      4))
  (mpz-kronecker-ui A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-si-kronecker (A B)
@deffnx {Method} mpz-si-kronecker ((A integer) (B mpz))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(2/@var{A})
when @var{A} odd, or (@var{A}/2)=0 when a even.

@lisp
(let ((A      15)
      (B      (mpz 4)))
  (mpz-si-kronecker A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-ui-kronecker (A B)
@deffnx {Method} mpz-ui-kronecker ((A integer) (B mpz))
Calculate the Jacobi symbol (@var{A}/@var{B}) with the Kronecker extension (@var{A}/2)=(2/@var{A})
when @var{A} odd, or (@var{A}/2)=0 when a even.

@lisp
(let ((A      15)
      (B      (mpz 4)))
  (mpz-ui-kronecker A B))
@result{} 1
@end lisp
@end deffn


@deffn {Generic Function} mpz-remove (@var{ROP} @var{OP} @var{F})
@deffnx {Method} mpz-remove ((@var{ROP} mpz) (@var{OP} mpz) (@var{F} mpz))
Remove all occurrences of the factor @var{F} from @var{OP} and store the result in @var{ROP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz 45))
      (F      (mpz 3)))
  (let ((rv (mpz-remove rop op F)))
    rv                  @result{} 2
    (mpz-get-si rop)))  @result{} 5
@end lisp
@end deffn


@deffn {Generic Function} mpz-fac-ui (@var{ROP} @var{N})
@deffnx {Method} mpz-fac-ui ((@var{ROP} mpz) (@var{N} integer))
Set @var{ROP} to the factorial of @var{N}.

@lisp
;; (* 4 3 2 1) => 24
(let ((rop    (mpz))
      (N      4))
  (mpz-fac-ui rop N)
  (mpz-get-si rop))
@result{} 24
@end lisp
@end deffn


@deffn {Generic Function} mpz-2fac-ui (@var{ROP} @var{N})
@deffnx {Method} mpz-2fac-ui ((@var{ROP} mpz) (@var{N} integer))
Set @var{ROP} to the double factorial of @var{N}: @var{N}!!.  See:

@center @url{https://en.wikipedia.org/wiki/Factorial#Multifactorials}

@lisp
;;from the full factorial select the first number every 2:
;;
;; (* 9 8 7 6 5 4 3 2 1) -> (* 9 7 5 3 1) => 945
;;    ^   ^   ^   ^   ^
;;
(let ((rop    (mpz))
      (N      9))
  (mpz-2fac-ui rop N)
  (mpz-get-si rop))
@result{} 945
@end lisp
@end deffn


@deffn {Generic Function} mpz-mfac-uiui (@var{ROP} @var{N} @var{M})
@deffnx {Method} mpz-mfac-uiui ((@var{ROP} mpz) (@var{N} integer) (@var{M} integer))
Set @var{ROP} to the @var{M}--multi--factorial of @var{N}: @var{N}!^(@var{M}).  See:

@center @url{https://en.wikipedia.org/wiki/Factorial#Multifactorials}

@lisp
;;from the full factorial select the first number every 4:
;;
;;(* 10 9 8 7 6 5 4 3 2 1) -> (* 10 6 2) => 120
;;   ^        ^       ^
(let ((rop    (mpz))
      (N      10)
      (M      4))
  (mpz-mfac-uiui rop N M)
  (mpz-get-si rop))
@result{} 120
@end lisp
@end deffn


@deffn {Generic Function} mpz-primorial-ui (@var{ROP} @var{N})
@deffnx {Method} mpz-primorial-ui ((@var{ROP} mpz) (@var{N} integer))
Set @var{ROP} to the primorial of @var{N}: the product of all positive prime numbers <=@var{N}.

@lisp
;; (* 7 5 3 2 1) => 210
(let ((rop    (mpz))
      (op     7))
  (mpz-primorial-ui rop op)
  (mpz-get-si rop))
@result{} 210
@end lisp
@end deffn


@deffn {Generic Function} mpz-bin-ui (@var{ROP} @var{N} @var{K})
@deffnx {Method} mpz-bin-ui ((@var{ROP} mpz) (@var{N} mpz) (@var{K} integer))
Compute the binomial coefficient @var{N} over @var{K} and store the result in @var{ROP}.

@lisp
(let ((rop    (mpz))
      (N      (mpz 4))
      (K      2))
  (mpz-bin-ui rop N K)
  (mpz-get-si rop))
@result{} 6
@end lisp
@end deffn


@deffn {Generic Function} mpz-bin-uiui (@var{ROP} @var{N} @var{K})
@deffnx {Method} mpz-bin-uiui ((@var{ROP} mpz) (@var{N} integer) (@var{K} integer))
Compute the binomial coefficient @var{N} over @var{K} and store the result in @var{ROP}.

@lisp
(let ((rop    (mpz))
      (N      4)
      (K      2))
  (mpz-bin-uiui rop N K)
  (mpz-get-si rop))
@result{} 6
@end lisp
@end deffn


@deffn {Generic Function} mpz-fib-ui (@var{FN} @var{N})
@deffnx {Method} mpz-fib-ui ((@var{FN} mpz) (@var{N} integer))
Set @var{FN} to to F[@var{N}]: the @var{N}'th Fibonacci number.

@lisp
(let ((FN     (mpz))
      (N      20))
  (mpz-fib-ui FN N)
  (mpz-get-si FN))
@result{} 6765
@end lisp
@end deffn


@deffn {Generic Function} mpz-fib2-ui (FN FNSUB1 N)
@deffnx {Method} mpz-fib2-ui ((FN mpz) (FNSUB1 mpz) (N integer))
Set @var{FN} to to F[@var{N}]: the @var{N}'th Fibonacci number.  Set @var{FNSUB1} to to
F[@var{N}-1].

@lisp
(let ((FN     (mpz))
      (FNSUB1 (mpz))
      (N      20))
  (mpz-fib2-ui FN FNSUB1 N)
  (mpz-get-si FN)               @result{} 6765
  (mpz-get-si FNSUB1))          @result{} 4181
@end lisp
@end deffn


@deffn {Generic Function} mpz-lucnum-ui (@var{LN} @var{N})
@deffnx {Method} mpz-lucnum-ui ((@var{LN} mpz) (@var{N} mpz))
Set @var{LN} to to L[@var{N}]: the @var{N}'th Lucas number.

@lisp
(let ((LN     (mpz))
      (N      9))
  (mpz-lucnum-ui LN N)
  (mpz-get-si LN))
@result{} 76
@end lisp
@end deffn


@deffn {Generic Function} mpz-lucnum2-ui (@var{LN} @var{LNSUB1} @var{N})
@deffnx {Method} mpz-lucnum2-ui ((@var{LN} mpz) (@var{LNSUB1} mpz) (@var{N} integer))
Set @var{LN} to to L[@var{N}]: the @var{N}'th Lucas number.  Set @var{LNSUB1} to to L[@var{N}-1].

@lisp
(let ((LN     (mpz))
      (LNSUB1 (mpz))
      (N      9))
  (mpz-lucnum2-ui LN LNSUB1 N)
  (mpz-get-si LN)       @result{} 76
  (mpz-get-si LNSUB1))  @result{} 47
@end lisp
@end deffn

@c page
@node integers bitlogic
@section Logical and bit manipulation functions


@c void mpz_and (mpz_t @var{ROP}, const mpz_t @vari{OP}, const mpz_t @varii{OP})
@deffn {Generic Function} mpz-and (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-and ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Set @var{ROP} to @vari{OP} bitwise--and @varii{OP}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz #b1010101))
      (op2    (mpz #b1101011)))
  (mpz-and rop op1 op2)
  (mpz-get-si rop))
@result{} #b1000001
@end lisp
@end deffn


@c void mpz_ior (mpz_t @var{ROP}, const mpz_t @vari{OP}, const mpz_t @varii{OP})
@deffn {Generic Function} mpz-ior (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-ior ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Set @var{ROP} to @vari{OP} bitwise inclusive--or @varii{OP}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz #b1010101))
      (op2    (mpz #b1110101)))
  (mpz-ior rop op1 op2)
  (mpz-get-si rop))
@result{} #b1110101
@end lisp
@end deffn


@c void mpz_xor (mpz_t @var{ROP}, const mpz_t @vari{OP}, const mpz_t @varii{OP})
@deffn {Generic Function} mpz-xor (@var{ROP} @vari{OP} @varii{OP})
@deffnx {Method} mpz-xor ((@var{ROP} mpz) (@vari{OP} mpz) (@varii{OP} mpz))
Set @var{ROP} to @vari{OP} bitwise exclusive--or @varii{OP}.

@lisp
(let ((rop    (mpz))
      (op1    (mpz #b1110101))
      (op2    (mpz #b1011101)))
  (mpz-xor rop op1 op2)
  (mpz-get-si rop))
@result{} #b0101000
@end lisp
@end deffn


@c void mpz_com (mpz_t @var{ROP}, const mpz_t @var{OP})
@deffn {Generic Function} mpz-com (@var{ROP} @var{OP})
@deffnx {Method} mpz-com ((@var{ROP} mpz) (@var{OP} mpz))
Set @var{ROP} to the one's complement of @var{OP}.

@lisp
(let ((rop    (mpz))
      (op     (mpz #b10)))
  (mpz-com rop op)
  (mpz-get-si rop))
@result{} -3
@end lisp
@end deffn


@c mp_bitcnt_t mpz_popcount (const mpz_t @var{OP})
@deffn {Generic Function} mpz-popcount (op)
@deffnx {Method} mpz-popcount ((@var{OP} mpz))
Return the population count of @var{OP}.

@lisp
(mpz-popcount (mpz #b1010101))
@result{} 4
@end lisp
@end deffn


@c mp_bitcnt_t mpz_hamdist (const mpz_t @vari{OP}, const mpz_t @varii{OP})
@deffn {Generic Function} mpz-hamdist (@vari{OP} @varii{OP})
@deffnx {Method} mpz-hamdist ((@vari{OP} mpz) (@varii{OP} mpz))
Return the hamming distance between the two operands.

@lisp
(let ((op1    (mpz 63))
      (op2    (mpz 70)))
  (mpz-hamdist op1 op2))
@result{} 5
@end lisp
@end deffn


@c mp_bitcnt_t mpz_scan0 (const mpz_t @var{OP}, mp_bitcnt_t STARTING_BIT)
@deffn {Generic Function} mpz-scan0 (op @var{STARTING-BIT})
@deffnx {Method} mpz-scan0 ((@var{OP} mpz) (@var{STARTING-BIT} integer))
Scan @var{OP} for the first 0 bit.

@lisp
(let ((op             (mpz #b1000110))
      (starting-bit   1))
  (mpz-scan0 op starting-bit))
@result{} 3

(let ((op             (mpz #b1011111))
      (starting-bit   2))
  (mpz-scan0 op starting-bit))
@result{} 5
@end lisp
@end deffn


@c mp_bitcnt_t mpz_scan1 (const mpz_t @var{OP}, mp_bitcnt_t STARTING_BIT)
@deffn {Generic Function} mpz-scan1 (op @var{STARTING-BIT})
@deffnx {Method} mpz-scan1 ((@var{OP} mpz) (@var{STARTING-BIT} integer))
Scan @var{OP} for the first 1 bit.

@lisp
(let ((op             (mpz #b1000110))
      (starting-bit   3))
  (mpz-scan1 op starting-bit))
@result{} 6

(let ((op             (mpz #b010000))
      (starting-bit   2))
  (mpz-scan1 op starting-bit))
@result{} 4
@end lisp
@end deffn


@c void mpz_setbit (mpz_t @var{ROP}, mp_bitcnt_t BIT_INDEX)
@deffn {Generic Function} mpz-setbit (@var{ROP} @var{BIT-INDEX})
@deffnx {Method} mpz-setbit ((@var{ROP} mpz) (@var{BIT-INDEX} integer))
Set bit BIT_INDEX in @var{ROP}.

@lisp
(let ((rop            (mpz))
      (bit-index      3))
  (mpz-setbit rop bit-index)
  (mpz-get-si rop))
@result{} 8
@end lisp
@end deffn


@c void mpz_clrbit (mpz_t @var{ROP}, mp_bitcnt_t BIT_INDEX)
@deffn {Generic Function} mpz-clrbit (@var{ROP} @var{BIT-INDEX})
@deffnx {Method} mpz-clrbit ((@var{ROP} mpz) (@var{BIT-INDEX} integer))
Clear bit BIT_INDEX in @var{ROP}.

@lisp
(let ((rop            (mpz #b00100))
      (bit-index      2))
  (mpz-clrbit rop bit-index)
  (mpz-get-si rop))
@result{} 0
@end lisp
@end deffn


@c void mpz_combit (mpz_t @var{ROP}, mp_bitcnt_t BIT_INDEX)
@deffn {Generic Function} mpz-combit (@var{ROP} @var{BIT-INDEX})
@deffnx {Method} mpz-combit ((@var{ROP} mpz) (@var{BIT-INDEX} integer))
Complement bit BIT_INDEX in @var{ROP}.

@lisp
(let ((rop            (mpz #b00100))
      (bit-index      2))
  (mpz-combit rop bit-index)
  (mpz-get-si rop))
@result{} 0
@end lisp
@end deffn


@c int mpz_tstbit (const mpz_t @var{OP}, mp_bitcnt_t BIT_INDEX)
@deffn {Generic Function} mpz-tstbit (op @var{BIT-INDEX})
@deffnx {Method} mpz-tstbit ((@var{OP} mpz) (@var{BIT-INDEX} integer))
Test bit BIT_INDEX in @var{OP} and return 0 or 1 accordingly.

@lisp
(let ((op             (mpz #b01000))
      (bit-index      3))
  (mpz-tstbit op bit-index))
@result{} t

(let ((op             (mpz #b10111))
      (bit-index      3))
  (mpz-tstbit op bit-index))
@result{} nil
@end lisp
@end deffn

@c page
@node integers random
@section Random number functions


@c void mpz_urandomb (mpz_t ROP, gmp_randstate_t STATE, mp_bitcnt_t N)
@deffn {Generic Function} mpz-urandomb (@var{ROP} @var{STATE} @var{N})
@deffnx {Method} mpz-urandomb ((@var{ROP} mpz) (@var{STATE} gmp-randstate) (@var{N} integer))
Generate a uniformly distributed random integer in the range 0 to 2^@var{N}-1, inclusive.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (N              3))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-urandomb rop state N)
  (let ((num (mpz-get-ui rop)))
    (and (>= num 0)
         (<  num (expt 2 N)))))
@result{} t
@end lisp
@end deffn


@c void mpz_urandomm (mpz_t ROP, gmp_randstate_t STATE, const mpz_t N)
@deffn {Generic Function} mpz-urandomm (@var{ROP} @var{STATE} @var{N})
@deffnx {Method} mpz-urandomm ((@var{ROP} mpz) (@var{STATE} gmp-randstate) (@var{N} mpz))
Generate a uniform random integer in the range 0 to @var{N}-1, inclusive.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (N              (mpz 3)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-urandomm rop state N)
  (let ((num (mpz-get-ui rop)))
    (and (>= num 0)
         (<  num (mpz-get-ui N)))))
@result{} t
@end lisp
@end deffn


@c void mpz_rrandomb (mpz_t ROP, gmp_randstate_t STATE, mp_bitcnt_t N)
@deffn {Generic Function} mpz-rrandomb (@var{ROP} @var{STATE} @var{N})
@deffnx {Method} mpz-rrandomb ((@var{ROP} mpz) (@var{STATE} gmp-randstate) (@var{N} integer))
Generate a random integer with long strings of zeros and ones in the binary representation.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (N              3))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-rrandomb rop state N)
  (let ((num (mpz-get-ui rop)))
    (and (>= num 0)
         (<  num (expt 2 N)))))
@result{} t
@end lisp
@end deffn


@c void mpz_random (mpz_t ROP, mp_size_t MAX_SIZE)
@deffn {Generic Function} mpz-random (@var{ROP} @var{MAX-SIZE})
@deffnx {Method} mpz-random ((@var{ROP} mpz) (@var{MAX-SIZE} integer))
Generate a random integer of at most @var{MAX-SIZE} limbs.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (max-size       1))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-random rop max-size)
  rop)
@result{} <some number>
@end lisp
@end deffn


@c void mpz_random2 (mpz_t ROP, mp_size_t MAX_SIZE)
@deffn {Generic Function} mpz-random2 (@var{ROP} @var{MAX-SIZE})
@deffnx {Method} mpz-random2 ((@var{ROP} mpz) (@var{MAX-SIZE} integer))
Generate a random integer of at most @var{MAX-SIZE} limbs, with long strings of zeros and ones in
the binary representation.

@lisp
(let ((rop            (mpz))
      (state          (gmp-randstate))
      (max-size       1))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (mpz-random2 rop max-size)
  rop)
@result{} <some number>
@end lisp
@end deffn

@c page
@node integers miscellaneous
@section Miscellaneous functions


@deffn {Generic Function} mpz-fits-ulong-p (@var{OP})
@deffnx {Method} mpz-fits-ulong-p ((@var{OP} mpz))
Return true if the operand fits an @code{unsigned long int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-slong-p (@var{OP})
@deffnx {Method} mpz-fits-slong-p ((@var{OP} mpz))
Return true if the operand fits a `@code{igned long int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-uint-p (@var{OP})
@deffnx {Method} mpz-fits-uint-p ((@var{OP} mpz))
Return true if the operand fits an @code{unsigned int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-sint-p (@var{OP})
@deffnx {Method} mpz-fits-sint-p ((@var{OP} mpz))
Return true if the operand fits n `@code{igned int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-ushort-p (@var{OP})
@deffnx {Method} mpz-fits-ushort-p ((@var{OP} mpz))
Return true if the operand fits an @code{unsigned short int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-sshort-p (@var{OP})
@deffnx {Method} mpz-fits-sshort-p ((@var{OP} mpz))
Return true if the operand fits a @code{signed short int}; otherwise return false.
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-odd-p (@var{OP})
@deffnx {Method} mpz-odd-p ((@var{OP} mpz))
Return true if the operand is odd; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-even-p (@var{OP})
@deffnx {Method} mpz-even-p ((@var{OP} mpz))
Return true if the operand is even; otherwise return false.
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-sizeinbase (@var{op} @var{base})
@deffnx {Method} mpz-sizeinbase ((@var{op} mpz) (@var{base} integer))
Return the size of @var{OP} measured in number of digits in the given @var{BASE}.

The argument @var{BASE} can vary from @math{2} to @math{62}.
@end deffn

@c page
@node rationals
@chapter Rational number objects and operations


@deftp {Object Type} mpq
Type of structures representing a multiple precision rational numbers.  It is a wrapper for the C
language type @objtype{mpq_t}.  These objects, and their internal representation, are correctly
garbage collected.
@end deftp


@menu
* rationals allocation::        Allocating rational numbers.
* rationals predicates::        Rational number predicates.
* rationals assignment::        Assigning values to rational
                                number objects.
* rationals conversion::        Converting rational numbers to
                                other objects.
@end menu

@c page
@node rationals allocation
@section Allocating rational numbers


@defun mpq &optional @var{INIT} @var{DENOMINATOR-INIT}
Build and return a new @objtype{mpq} object instance.  When called with no arguments: the object is
uninitialised.

When the @var{INIT} argument is provided and the argument @var{DENOMINATOR-INIT} is not: @var{INIT}
must be an initialisation value for the @objtype{mpq} object.  It can be: a floating--point number;
an @objtype{mpz} object; an @objtype{mpq} object; an @objtype{mpf} object.

@lisp
(let ((op (mpq 1.2)))
  (mpq-get-str 10 op))
@result{} "5404319552844595/4503599627370496"
@end lisp

When both the @var{INIT} and @var{DENOMINATOR-INIT} arguments are provided: they must be
initialisation values for the numerator and the denominator of the new rational number.  They can
be: exact integer numbers.

@lisp
(let ((op (mpq 3 4)))
  (mpq-get-str 10 op))
@result{} "3/4"
@end lisp

When both the @var{INIT} and @var{DENOMINATOR-INIT} arguments are missing: the returned object is
set to zero.

@lisp
(let ((op (mpq)))
  (mpq-get-str 10 op))
@result{} "0"
@end lisp
@end defun

@c page
@node rationals predicates
@section Rational number predicates


@defun mpq-p @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{mpq}; otherwise return @false{}.

@lisp
(mpq-p (mpq))   @result{} t
(mpq-p 123)     @result{} nil
@end lisp
@end defun

@c page
@node rationals assignment
@section Assigning values to rational number objects


@defun mpq-set @var{rop} @var{op}
Assign the value of @var{op} to @var{rop}; both the operands must be of type @objtype{mpq}.

@lisp
(let ((rop (mpq))
      (op  (mpq)))
  (mpq-set-si rop 3 4)
  (mpq-set    op rop)
  (mpq-get-str 10 op))
@result{} "3/4"
@end lisp
@end defun


@defun mpq-set-si @var{rop} @var{numerator-integer} @var{denominator-integer}
Assign the value of the signed exact integer numbers @var{numerator-integer} and
@var{denominator-integer} to the @objtype{mpq} object @var{rop}.

@lisp
(let ((rop (mpq)))
  (mpq-set-si rop 3 4)
  (mpq-get-str 10 rop))
@result{} "3/4"
@end lisp
@end defun


@defun mpq-set-ui @var{rop} @var{numerator-integer} @var{denominator-integer}
Assign the value of the unsigned exact integer numbers @var{numerator-integer} and
@var{denominator-integer} to the @objtype{mpq} object @var{rop}.

@lisp
(let ((rop (mpq)))
  (mpq-set-ui rop 3 4)
  (mpq-get-str 10 rop))
@result{} "3/4"
@end lisp
@end defun


@defun mpq-set-d @var{rop} @var{flo}
Assign the value of a floating--point object to an @objtype{mpq} object.

@lisp
(let ((rop (mpq)))
  (mpq-set-d rop 1.2)
  (mpq-get-str 10 rop))
@result{} "5404319552844595/4503599627370496"
@end lisp
@end defun


@defun mpq-set-z @var{rop} @var{op}
Assign the value of an @objtype{mpz} object to an @objtype{mpq} object.

@lisp
(let ((rop (mpq))
      (op  (mpz 123)))
  (mpq-set-z rop op)
  (mpq-get-str 10 rop))
@result{} "123"
@end lisp
@end defun


@defun mpq-set-f @var{rop} @var{op}
Assign the value of an @objtype{mpf} object to an @objtype{mpq} object.

@lisp
(let ((rop (mpq))
      (op  (mpf 1.2)))
  (mpq-set-f rop op)
  (mpq-get-str 10 rop))
@result{} "5404319552844595/4503599627370496"
@end lisp
@end defun


@defun mpq-set-str @var{rop} @var{str} @var{base}
Assign the value of a string object to an @objtype{mpq} object.  The argument @var{base} must be an
exact integer representing the base of the numeric string representation: @math{0} or a value
between @math{2} and @math{62}.

@lisp
(let ((rop (mpq)))
  (mpq-set-str rop "3/4" 10)
  (mpq-get-str 10 rop))
@end lisp
@end defun


@defun mpq-swap @vari{op} @varii{op}
Swap the values between two @objtype{mpq} objects.

@lisp
(let ((op1 (mpq))
      (op2 (mpq)))
  (mpq-set-si op1 3 4)
  (mpq-set-si op2 5 6)
  (mpq-swap op1 op2)
  (mpq-get-str 10 op2)  @result{} "3/4"
  (mpq-get-str 10 op1)  @result{} "5/6"
  )
@end lisp
@end defun

@c page
@node rationals conversion
@section Converting rational numbers to other objects


@defun mpq-get-d @var{op}
Convert an object @var{op} of type @objtype{mpq} to a floating--point number.

@lisp
(mpq-get-d (mp1 12.3))  @result{} 12.3
@end lisp
@end defun


@defun mpq-get-str @var{base} @var{op}
Convert an object @var{op} of type @objtype{mpq} to a string; return the resulting string.
@var{base} must be an exact integer representing the base of the numeric string representation:
positive between @math{2} and @math{36} or negative between @math{-2} and @math{-36}.

@lisp
(defconst op (mpq))
(mpq-set-si op 17 13)

(mpq-get-str +10 op)    @result{} "17/13"
(mpq-get-str +16 op)    @result{} "11/d"
(mpq-get-str -16 op)    @result{} "11/D"
@end lisp
@end defun

@c page
@node floats
@chapter Floating-point number objects and operations


@deftp {Object Type} mpf
Type of structures representing a multiple precision floating--point numbers.  It is a wrapper for
the C language type @objtype{mpf_t}.  These objects, and their internal representation, are
correctly garbage collected.
@end deftp


@menu
* floats allocation::           Allocating floating-point numbers.
* floats initialisation::       Floating-point numbers initialisation
                                functions.
* floats predicates::           Floating-point number predicates.
* floats assignment::           Assigning values to floating-point
                                number objects.
* floats conversion::           Converting floating-point numbers to
                                other objects.
@end menu

@c page
@node floats allocation
@section Allocating floating--point numbers


@defun mpf &optional @var{INIT}
Build and return a new @objtype{mpf} object instance.  When called with no arguments: the object is
uninitialised.

When the @var{INIT} argument is provided: it must be an initialisation value for the @objtype{mpf}
object.  I can be: an exact integer number; a floating--point number; an @objtype{mpz} object; an
@objtype{mpq} object; an @objtype{mpf} object.

@lisp
(let ((op (mpf 123)))
  (mpf-get-str* 10 5 op))
@result{} "+0.123e+3"
@end lisp

When the @var{INIT} argument is missing: the returned object is set to zero.

@lisp
(let ((op (mpf)))
  (mpf-get-str* 10 5 op))
@result{} "0.0"
@end lisp
@end defun

@c page
@node floats initialisation
@section Floating--point numbers initialisation functions


@defun mpf-set-default-prec @var{prec}
Set the default precision of @objtype{mpf} object to at least @var{prec}, which must be an exact
integer number object.
@end defun


@defun mpf-get-default-prec
Return an exact integer number representing the current default precision of @objtype{mpf} objects.
@end defun


@defun mpf-set-prec @var{rop} @var{prec}
Set the precision of the @objtype{mpf} object @var{rop} to at least @var{prec}, which must be an
exact integer number object.
@end defun


@defun mpf-get-prec @var{rop}
Return an exact integer number representing the precision of the @objtype{mpf} object @var{rop}.
@end defun

@c page
@node floats predicates
@section Floating--point number predicates


@defun mpf-p @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{mpf}; otherwise return @false{}.

@lisp
(mpf-p (mpf))   @result{} t
(mpf-p 123)     @result{} nil
@end lisp
@end defun

@c page
@node floats assignment
@section Assigning values to floating--point number objects


@defun mpf-set @var{rop} @var{op}
Assign the value of @var{op} to @var{rop}; both the operands must be of type @objtype{mpf}.

@lisp
@end lisp
@end defun


@defun mpf-set-si @var{rop} @var{int}
Assign the value of an exact integer object to an @objtype{mpf} object.

@lisp
@end lisp
@end defun


@defun mpf-set-d @var{rop} @var{flo}
Assign the value of a floating--point object to an @objtype{mpf} object.

@lisp
@end lisp
@end defun


@defun mpf-set-z @var{rop} @var{op}
Assign the value of an @objtype{mpz} object to an @objtype{mpf} object.

@lisp
@end lisp
@end defun


@defun mpf-set-q @var{rop} @var{op}
Assign the value of an @objtype{mpq} object to an @objtype{mpf} object.

@lisp
@end lisp
@end defun


@defun mpf-set-str @var{rop} @var{str} @var{base}
Assign the value of a string object to an @objtype{mpf} object.  The argument @var{base} must be an
exact integer representing the base of the numeric string representation: a positive value between
@math{2} and @math{62} or a negative value between @math{-2} and @math{-62}.

@lisp
@end lisp
@end defun


@defun mpf-swap @vari{op} @varii{op}
Swap the values between two @objtype{mpf} objects.

@lisp
@end lisp
@end defun

@c page
@node floats conversion
@section Converting floating--point numbers to other objects


@defun mpf-get-ui @var{op}
Convert an object @var{op} of type @objtype{mpf} to an unsigned exact integer number.

@lisp
(mpf-get-ui (mpf 123))  @result{} 123
@end lisp
@end defun


@defun mpf-get-si @var{op}
Convert an object @var{op} of type @objtype{mpf} to an signed exact integer number.

@lisp
(mpf-get-si (mpf 123))  @result{} 123
@end lisp
@end defun


@defun mpf-get-d @var{op}
Convert an object @var{op} of type @objtype{mpf} to a floating--point number.

@lisp
(mpf-get-d (mpf 123))  @result{} 123.0
@end lisp
@end defun


@defun mpf-get-d-2exp @var{op}
Convert an object @var{op} of type @objtype{mpf} to a floating--point number, yielding the exponent
separately.  The return value is a pair whose car is a floating--point number and whose cdr is the
exponent:

@lisp
(defconst rv (mpf-get-d-2exp (mpf 123)))

rv                                      @result{} (0.9609375 . 7)
(* (car rv) (expt 2 (cdr rv)))          @result{} 123.0
@end lisp
@end defun


@defun mpf-get-str @var{base} @var{ndigits} @var{op}
Convert an object @var{op} of type @objtype{mpf} to a string; return a pair object whose car is a
string representing the mantissa and whose cdr is an exact integer representing the exponent.

The arguments @var{base} must be an exact integer representing the base of the numeric string
representation: positive between @math{+2} and @math{+62} or negative between @math{-2} and
@math{-36}.

The argument @var{ndigits} must be an exact integer representing the number of digits to generate.

@lisp
(let ((op       (mpf 15))
      (ndigits  5))
  (mpf-get-str +10 ndigits op)  @result{} ("15" . 2)
  (mpf-get-str +16 ndigits op)  @result{} ("f"  . 1)
  (mpf-get-str -16 ndigits op)  @result{} ("F"  . 1)
  )

(let ((op       (mpf))
      (ndigits  5))
  (mpf-set-d op 12.34)
  (mpf-get-str +10 ndigits op))
@result{} ("1234" . 2)
@end lisp
@end defun


@defun mpf-get-str* @var{base} @var{ndigits} @var{op}
Convert an object @var{op} of type @objtype{mpf} to a formatted string; return the string.  The
arguments @var{base} and @var{ndigits} are the same as documented for @func{mpf-get-str}.

@lisp
(let ((op       (mpf))
      (ndigits  5))
  (mpf-set-d op +0.001234)
  (mpf-get-str* +10 ndigits op))
@result{} "+0.1234e-2"

(let ((op       (mpf))
      (ndigits  5))
  (mpf-set-d op +12.34)
  (mpf-get-str* +10 ndigits op))
@result{} "+0.1234e+2"

(mpf-get-str* 10 5 (mpf))
@result{} "0.0"
@end lisp
@end defun

@c page
@node random
@chapter Random numbers generation


@deftp {Object Type} gmp-randstate
Type of structures representing the state of a random numbers generator.  It is a wrapper for the C
language type @objtype{gmp_randstate}.  These objects, and their internal representation, are
correctly garbage collected.
@end deftp


@menu
* random obj::                  Random number generator objects.
* random init::                 Random number generators initialisation.
* random seed::                 Random number generators seeding.
* random gen::                  Generating random numbers.
@end menu

@c page
@node random obj
@section Random number generator objects


@defun gmp-randstate
Build and return a new @objtype{gmp-randstate} object.  The generator is @strong{uninitialised}.
@end defun


@defun gmp-randstate-p @var{obj}
Return true if @var{obj} is an instance of @objtype{gmp-randstate}; otherwise return false.
@end defun

@c page
@node random init
@section Random number generators initialisation


@c void gmp_randinit_default (gmp_randstate_t STATE)
@deffn {Generic Function} gmp-randinit-default@strong{ (@var{STATE}})
@deffnx {Method} gmp-randinit-default ((@var{STATE} gmp-randstate))
Initialise @var{STATE} with a default algorithm.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c void gmp_randinit_mt (gmp_randstate_t STATE)
@deffn {Generic Function} gmp-randinit-mt (@var{STATE})
@deffnx {Method} gmp-randinit-mt ((@var{STATE} gmp-randstate))
Initialise @var{STATE} for a Mersenne Twister algorithm.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-mt state)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c void gmp_randinit_lc_2exp (gmp_randstate_t STATE, const mpz_t A, unsigned long C, mp_bitcnt_t M2EXP)
@deffn {Generic Function} gmp-randinit-lc-2exp (@var{STATE} @var{A} @var{C} M2EXP)
@deffnx {Method} gmp-randinit-lc-2exp ((@var{STATE} gmp-randstate) (@var{A} mpz) (@var{C} integer) (@var{M2EXP} integer))
Initialise @var{STATE} with a linear congruential algorithm.

@lisp
(let ((state  (gmp-randstate))
      (A      (mpz 19))
      (C      2)
      (M2EXP  3))
  (gmp-randinit-lc-2exp state A C M2EXP)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c int gmp-randinit-lc-2exp_size (gmp_randstate_t STATE, mp_bitcnt_t SIZE)
@deffn {Generic Function} gmp-randinit-lc-2exp-size (@var{STATE} @var{SIZE})
@deffnx {Method} gmp-randinit-lc-2exp-size ((@var{STATE} gmp-randstate) (@var{SIZE} integer))
Initialise @var{STATE} with a linear congruential algorithm.

@lisp
(let ((state  (gmp-randstate))
      (size   30))
  (gmp-randinit-lc-2exp-size state size)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c void gmp-randinit-set (gmp_randstate_t ROP, gmp_randstate_t OP)
@deffn {Generic Function} gmp-randinit-set (@var{ROP} @var{OP})
@deffnx {Method} gmp-randinit-set ((@var{ROP} gmp-randstate) (@var{OP} gmp-randstate))
Initialise @var{ROP} with a copy of the algorithm and state from @var{OP}.

@lisp
(let ((rop    (gmp-randstate))
      (op     (gmp-randstate)))
  (gmp-randinit-default op)
  (gmp-randseed-ui op 123)
  (gmp-randinit-set rop op)
  (let ((num (gmp-urandomb-ui op 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn

@c page
@node random seed
@section Random number generators seeding


@c void gmp_randseed (gmp_randstate_t STATE, const mpz_t SEED)
@deffn {Generic Function} gmp-randseed (@var{STATE} @var{SEED})
@deffnx {Method} gmp-randseed ((@var{STATE} gmp-randstate) (@var{SEED} mpz))
Set an initial seed value into @var{STATE}.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed state (mpz 123))
  (let ((num (gmp-urandomm-ui state 3)))
    (and (<= 0 num) (< num 3))))
@result{} t
@end lisp
@end deffn


@c void gmp_randseed_ui (gmp_randstate_t STATE, unsigned long int SEED)
@deffn {Generic Function} gmp-randseed-ui (@var{STATE} @var{SEED})
@deffnx {Method} gmp-randseed-ui ((@var{STATE} gmp-randstate) (@var{SEED} integer))
Set an initial seed value into @var{STATE}.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 12)
  (let ((num (gmp-urandomm-ui state 3)))
    (and (<= 0 num) (< num 3))))
@result{} t
@end lisp
@end deffn

@c page
@node random gen
@section Generating random numbers


@c unsigned long gmp_urandomb_ui (gmp_randstate_t STATE, unsigned long N)
@deffn {Generic Function} gmp-urandomb-ui (@var{state} @var{N})
@deffnx {Method} gmp-urandomb-ui ((@var{state} gmp-randstate) (@var{N} integer))
Return a uniformly distributed random number of @var{N} bits, in the range 0 to 2^@var{N}-1
inclusive.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomb-ui state 3)))
    (and (<= 0 num) (< num (expt 2 3)))))
@result{} t
@end lisp
@end deffn


@c unsigned long gmp_urandomm_ui (gmp_randstate_t STATE, unsigned long N)
@deffn {Generic Function} gmp-urandomm-ui (@var{state} @var{N})
@deffnx {Method} gmp-urandomm-ui ((@var{state} gmp-randstate) (@var{N} integer))
Return a uniformly distributed random number in the range 0 to @var{N}-1, inclusive.

@lisp
(let ((state  (gmp-randstate)))
  (gmp-randinit-default state)
  (gmp-randseed-ui state 123)
  (let ((num (gmp-urandomm-ui state 3)))
    (and (<= 0 num) (< num 3))))
@result{} t
@end lisp
@end deffn

@c page
@node errors
@chapter How errors are signalled


Occasionally the functions in @value{PACKAGE} signal an error; the following error symbols are
defined.


@defvr {Error Symbol} mmux-gmp-error
The base type of all the error symbols.
@end defvr


@defvr {Error Symbol} mmux-gmp-invalid-initialisation-value
@defvrx {Parent Error Symbol} mmux-gmp-error
Used to signal an invalid initialisation value for an object constructor.
@end defvr


@defvr {Error Symbol} mmux-gmp-no-memory-error
@defvrx {Parent Error Symbol} mmux-gmp-error
Used to signal that there was not enough memory to allocate an object.
@end defvr


@defvr {Error Symbol} mmux-gmp-string-too-long
@defvrx {Parent Error Symbol} mmux-gmp-error
Used to signal that a string argument is to long to be processed.  As example, this may happen when
converting strings to and from elisp objects.
@end defvr

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

We can find @gmp{} here:

@center @url{https://gmplib.org/}

We can found informations and examples about Emacs modules at the repository mirror, under the
@file{modules} directory:

@center @url{https://github.com/emacs-mirror/emacs}

There is also a list of resources about Emacs modules:

@center @url{https://github.com/emacs-pe/emacs-modules}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

