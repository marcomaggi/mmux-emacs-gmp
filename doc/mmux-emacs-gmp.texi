\input texinfo.tex
@c %**start of header
@setfilename mmux-emacs-gmp.info
@settitle MMUX Emacs GMP
@c %**end of header

@include version.texi
@include macros.texi
@include elisp-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX Emacs GMP

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX Emacs GMP

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-emacs-gmp

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2020

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_EMACS_GMP
@set PackagePkgconfigModule             @code{mmux-emacs-gmp}
@set PackageLibsVar                     @env{MMUX_EMACS_GMP_LIBS}
@set PackageCflagsVar                   @env{MMUX_EMACS_GMP_CFLAGS}

@set PackageLibstem                     @file{mmux-emacs-gmp}
@set PackageSharedLibraryBasename       @file{libmmux-emacs-gmp}

@set PackageEmacsModule                 @file{mmux-emacs-gmp}
@set PackageHeader                      mmux-emacs-gmp.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set PackageApiCPrefixLower             mmux_emacs_gmp_
@set PackageApiCPrefixUpper             MMUX_EMACS_GMP_
@set PackageApiElispPrefix              mmux-gmp-

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set GMPversion                 6.1.2+

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro gmpref{NODE, TITLE}
@xref{\NODE\,\TITLE\,\TITLE\,gmp}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a @gnu{} Emacs module
implemented on top of a C11 language library, providing an interface to the @gmp{} library.

The library supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
26+ and @gmp{} version @value{GMPversion}.  This package depends upon the external packages:
@samp{cl-lib}.  To run the test suite: this package requires the ERT package.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-emacs-gmp: (mmux-emacs-gmp).       MMUX Emacs GMP, an interface to GMP.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* integers::                    Exact integer objects and operations.
* rationals::                   Rational number objects and operations.
* floats::                      Floating-point number objects and operations.
* errors::                      How errors are signalled.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* modules: (elisp)Writing Dynamic Modules.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a @gnu{} Emacs module
implemented on top of a C11 language library, providing an interface to the @gmp{} library.

The library supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
26+ and @gmp{} version @value{GMPversion}.  This package depends upon the external packages:
@samp{cl-lib}.  To run the test suite: this package requires the ERT package.

@value{PACKAGE} installs a single elisp module @value{PackageEmacsModule} and a C language shared
library with basename @value{PackageSharedLibraryBasename} (using the @gnu{} Libtool
infrastructure).  All the elisp definition names are prefixed with either
@code{@value{PackageApiElispPrefix}}, @samp{mpz-}, @samp{mpq-} or @samp{mpf-}.  The C language
shared library is installed under @samp{$libdir}, for example:

@center @file{/usr/local/lib64}

@noindent
while the elisp module goes under @samp{$lispdir}, for example:

@center @file{/usr/local/share/emacs/site-lisp}

@noindent
so to load the module (under an Emacs installation with dynamic modules enabled) we should do
something like:

@lisp
(add-to-list 'load-path "/usr/local/lib64"
                        "/usr/local/share/emacs/site-lisp")
(require 'mmux-emacs-gmp)
@end lisp

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
It might be possible that we want to write a C language library making use of the facilities of this
package; so @value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the C
language function names in the @api{} are prefixed with @code{@value{PackageApiCPrefixLower}}; all
the C language preprocessor symbol names are prefixed with @code{@value{PackageApiCPrefixUpper}};
all the type names are prefixed with @code{@value{PackageApiCPrefixLower}} and suffixed with
@code{_t}.

Most of the functions implemented by @gmp{} are wrapped by @value{PACKAGE}, with the exclusion of
the initialisation functions and some other functions.  The elisp function names are equal to the C
language function names, with each underscore turned into a dash; so @cfunc{mpz_get_str} becomes
@func{mpz-get-str}.  Only a brief description of the arguments is given in this document: for the
full meaning of the function arguments we should refer to the original @gmp{} documentation.

@menu
* overview linking::            Linking code with the library.
@end menu

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@defun mmux-gmp-version-string
Return a string representing the interface version number.
@end defun


@defun mmux-gmp-version-interface-current
Return an integer representing the library interface current number.
@end defun


@defun mmux-gmp-version-interface-revision
Return an integer representing the library interface current revision number.
@end defun


@defun mmux-gmp-version-interface-age
Return an integer representing the library interface current age.
@end defun


@deftypefun {char const *} mmux_emacs_gmp_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_emacs_gmp_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_emacs_gmp_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_emacs_gmp_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node integers
@chapter Exact integer objects and operations


@deftp {Object Type} mpz
Type of structures representing a multiple precision exact integer.  It is a wrapper for the C
language type @objtype{mpz_t}.  These objects, and their internal representation, are correctly
garbage collected.
@end deftp


@menu
* integers allocation::         Allocating exact integers.
* integers predicates::         Exact integer predicates.
* integers assignment::         Assigning values to objects.
* integers conversion::         Converting exact integers to
                                other objects.
* integers arithmetic::         Arithmetic operations.
* integers division::           Division operations.
* integers exponentiation::     Exponentiation operations.
* integers roots::              Root extraction functions.
* integers comparison::         Commparison functions.
* integers miscellaneous::      Miscellaneous functions.
@end menu

@c page
@node integers allocation
@section Allocating exact integers


@defun mpz &optional @var{INIT}
Build and return a new @objtype{mpz} object instance.  When called with no arguments: the object is
uninitialised.

When the @var{INIT} argument is provided: it must be an initialisation value for the @objtype{mpz}
object.  I can be: an exact integer number; a floating--point number; an @objtype{mpz} object; an
@objtype{mpq} object; an @objtype{mpf} object.

When the @var{INIT} argument is missing: the returned object is initialised to zero.
@end defun

@c page
@node integers predicates
@section Exact integer predicates


@defun mpz-p @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{mpz}; otherwise return @false{}.

@lisp
(mpz-p (mpz))   @result{} t
(mpz-p 123)     @result{} nil
@end lisp
@end defun

@c page
@node integers assignment
@section Assigning values to objects


@defun mpz-set @var{rop} @var{op}
Assign the value of @var{op} to @var{rop}; both the operands must be of type @objtype{mpz}.

@lisp
(defconst rop (mpz))
(defconst op  (mpz))

(mpz-set-si rop 123)
(mpz-set    op rop)
(mpz-get-str 10 op)     @result{} "123"
@end lisp
@end defun


@defun mpz-set-si @var{rop} @var{int}
Assign the value of an exact integer object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))

(mpz-set-si rop 123)
(mpz-get-str 10 op)     @result{} "123"
@end lisp
@end defun


@defun mpz-set-d @var{rop} @var{flo}
Assign the value of a floating--point object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))

(mpz-set-d rop 12.3)
(mpz-get-str 10 rop)    @result{} "12"
@end lisp
@end defun


@defun mpz-set-q @var{rop} @var{op}
Assign the value of an @objtype{mpq} object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))
(defconst op  (mpq))

(mpq-set-si op 10 7)
(mpz-set-q rop op)
(mpz-get-str 10 rop)    @result{} "1"
@end lisp
@end defun


@defun mpz-set-f @var{rop} @var{op}
Assign the value of an @objtype{mpf} object to an @objtype{mpz} object.

@lisp
(defconst rop (mpz))
(defconst op  (mpf))

(mpf-set-d op 12.34)
(mpz-set-f rop op)
(mpz-get-str 10 rop)    @result{} "12"
@end lisp
@end defun


@defun mpz-set-str @var{rop} @var{str} @var{base}
Assign the value of a string object to an @objtype{mpz} object.  The argument @var{base} must be an
exact integer representing the base of the numeric string representation: @math{0} or a value
between @math{2} and @math{32}.

@lisp
(defconst rop (mpz))

(mpz-set-str rop "123" 10)
(mpz-get-str 10 rop)    @result{} "123"
@end lisp
@end defun


@defun mpz-swap @vari{op} @varii{op}
Swap the values between two @objtype{mpz} objects.

@lisp
(defconst op1 (mpz))
(defconst op2 (mpz))

(mpz-set-si op1 123)
(mpz-set-si op2 456)
(mpz-swap op1 op2)
(mpz-get-str 10 op1)  @result{} "456"
(mpz-get-str 10 op2)  @result{} "123"
@end lisp
@end defun

@c page
@node integers conversion
@section Converting exact integers to other objects


@defun mpz-get-ui @var{op}
Convert an object @var{op} of type @objtype{mpz} to an unsigned exact integer number.

@lisp
(mpz-get-ui (mpz 123))  @result{} 123
@end lisp
@end defun


@defun mpz-get-si @var{op}
Convert an object @var{op} of type @objtype{mpz} to an signed exact integer number.

@lisp
(mpz-get-si (mpz 123))  @result{} 123
@end lisp
@end defun


@defun mpz-get-d @var{op}
Convert an object @var{op} of type @objtype{mpz} to a floating--point number.

@lisp
(mpz-get-d (mpz 123))  @result{} 123.0
@end lisp
@end defun


@defun mpz-get-d-2exp @var{op}
Convert an object @var{op} of type @objtype{mpz} to a floating--point number, yielding the exponent
separately.  The return value is a pair whose car is a floating--point number and whose cdr is the
exponent:

@lisp
(defconst rv (mpz-get-d-2exp (mpz 123)))

rv                                      @result{} (0.9609375 . 7)
(* (car rv) (expt 2 (cdr rv)))          @result{} 123.0
@end lisp
@end defun


@defun mpz-get-str @var{base} @var{op}
Convert an object @var{op} of type @objtype{mpz} to a string; return the resulting string.
@var{base} must be an exact integer representing the base of the numeric string representation:
positive between @math{2} and @math{36} or negative between @math{-2} and @math{-36}.

@lisp
(defconst op (mpz))
(mpz-set-si op 15)
(mpz-get-str  10 op)    @result{} "15"
(mpz-get-str  16 op)    @result{} "f"
(mpz-get-str -16 op)    @result{} "F"
@end lisp
@end defun

@c page
@node integers arithmetic
@section Arithmetic operations


@defun mpz-add @var{rop} @vari{op} @varii{op}
Add two @objtype{mpz} objects.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 10))
      (op2      (mpz 1)))
  (mpz-add rop op1 op2)
  (mpz-get-ui rop))
@result{} 11
@end lisp
@end defun


@defun mpz-add-ui @var{rop} @vari{op} @varii{op}
Add an @objtype{mpz} object to an unsigned exact integer number.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 10))
      (op2      1))
  (mpz-add-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} 11
@end lisp
@end defun


@defun mpz-sub @var{rop} @vari{op} @varii{op}
Subtract two @objtype{mpz} objects.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 11))
      (op2      (mpz 1)))
  (mpz-sub rop op1 op2)
  (mpz-get-ui rop))
@result{} 10
@end lisp
@end defun


@defun mpz-sub-ui @var{rop} @vari{op} @varii{op}
Subtract an unsigned exact integer number from an @objtype{mpz} object.

@lisp
(let ((rop      (mpz))
      (op1      (mpz 11))
      (op2      1))
  (mpz-sub-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} 10
@end lisp
@end defun


@defun mpz-addmul @var{rop} @vari{op} @varii{op}
Multiply two @objtype{mpz} objects, then add the result to another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     (mpz 2)))
  (mpz-addmul rop op1 op2)
  (mpz-get-ui rop))
@result{} (+ 100 (* 11 2))
@end lisp
@end defun


@defun mpz-addmul-ui @var{rop} @vari{op} @varii{op}
Multiply an @objtype{mpz} object with an unsigned exact integer number, then add the result to
another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     2))
  (mpz-addmul-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} (+ 100 (* 11 2))
@end lisp
@end defun


@defun mpz-submul @var{rop} @vari{op} @varii{op}
Multiply two @objtype{mpz} objects, then subtract the result from another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     (mpz 2)))
  (mpz-submul rop op1 op2)
  (mpz-get-ui rop))
@result{} (- 100 (* 11 2))
@end lisp
@end defun


@defun mpz-submul-ui @var{rop} @vari{op} @varii{op}
Multiply an @objtype{mpz} object with an unsigned exact integer number, then subtract the result
from another @objtype{mpz} object.

@lisp
(let ((rop     (mpz 100))
      (op1     (mpz 11))
      (op2     2))
  (mpz-submul-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} (- 100 (* 11 2))
@end lisp
@end defun


@defun mpz-mul @var{rop} @vari{op} @varii{op}
Multiply two @objtype{mpz} objects.

@lisp
(let ((rop     (mpz))
      (op1     (mpz 111))
      (op2     (mpz 2)))
  (mpz-mul rop op1 op2)
  (mpz-get-ui rop))
@result{} 222
@end lisp
@end defun


@defun mpz-mul-si @var{rop} @vari{op} @varii{op}
Multiply an @objtype{mpz} object by a signed exact integer number.

@lisp
(let ((rop     (mpz))
      (op1     (mpz 111))
      (op2     2))
  (mpz-mul-si rop op1 op2)
  (mpz-get-ui rop))
@result{} 222
@end lisp
@end defun


@defun mpz-mul-ui @var{rop} @vari{op} @varii{op}
Multiply an @objtype{mpz} object by an unsigned exact integer number.

@lisp
(let ((rop     (mpz))
      (op1     (mpz 111))
      (op2     2))
  (mpz-mul-ui rop op1 op2)
  (mpz-get-ui rop))
@result{} 222
@end lisp
@end defun


@defun mpz-mul-2exp @var{rop} @var{op} @var{bitcnt}
Left shift an @objtype{mpz} object.

@lisp
(let ((rop     (mpz))
      (op      (mpz #b10101))
      (bitcnt  2))
  (mpz-mul-2exp rop op bitcnt)
  (mpz-get-ui rop))
@result{} #b1010100
@end lisp
@end defun


@defun mpz-neg @var{rop} @var{op}
Negate an @objtype{mpz} object.

@lisp
(let ((rop     (mpz))
      (op      (mpz 123)))
  (mpz-neg rop op)
  (mpz-get-si rop))
@result{} -123
@end lisp
@end defun


@defun mpz-abs @var{rop} @var{op}
Compute the absolute value of an @objtype{mpz} object.

@lisp
(let ((rop     (mpz))
      (op      (mpz -123)))
  (mpz-abs rop op)
  (mpz-get-ui rop))
@result{} 123
@end lisp
@end defun

@c page
@node integers division
@section Division operations


The division functions divide numerator @math{N} by the denominator @math{D}, forming a quotient
@math{Q} and/or remainder @math{R}; for the @code{2exp} functions, @math{D=2^B} where @math{B} is
the bit count.  The rounding is in three styles, each suiting different applications.

@table @code
@item cdiv
Rounds @math{Q} up towards +infinity, and @math{R} will have the opposite sign to @math{D}.  The
@code{c} stands for ``ceil''.

@item fdiv
Rounds @math{Q} down towards -infinity, and @math{R} will have the same sign as @math{D}.  The @code{f}
stands for ``floor''.

@item tdiv
Rounds @math{Q} towards zero, and @math{R} will have the same sign as @math{N}.  The @code{t} stands
for ``truncate''.
@end table

In all cases @math{Q} and @math{R} will satisfy @math{N = Q * D + R}, and @math{R} will satisfy
@math{0 <= abs(R) < abs(D)}.

@menu
* integers division ceil::      Rounding towards +infinity (ceil).
* integers division floor::     Rounding towards -infinity (floor).
* integers division truncate::  Rounding towards zero (truncate).
* integers division modulo::    Modulo functions.
* integers division exact::     Exact division.
@end menu

@c page
@node integers division ceil
@subsection Rounding towards +infinity (ceil)


For the examples in this section, remember that the template operation is:

@example
N = Q * D + R
@end example

@noindent
and with ceil rounding we have:

@example
N = 10
D = 3
Q = ceil(N/D) = ceil(10 / 3) = ceil(3.33333) = 4
R = N - Q * D = 10 - 4 * 3 = -2
@end example

@noindent
for the @code{2exp} functions:

@example
N = 10
B = 3
D = 2^B = 2^3 = 8
Q = ceil(N/D) = ceil(10 / 8) = ceil(1.25) = 2
R = N - Q * D = 10 - 2 * 8 = 10 - 16 = -6
@end example


@defun mpz-cdiv-q @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-cdiv-q Q N D)
  (mpz-get-si Q))
@result{} 4
@end lisp
@end defun


@defun mpz-cdiv-r @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-cdiv-r R N D)
  (mpz-get-si R))
@result{} -2
@end lisp
@end defun


@defun mpz-cdiv-qr @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
  (let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-cdiv-qr Q R N D)
  (mpz-get-si Q)        @result{} +4
  (mpz-get-si R))       @result{} -2
@end lisp
@end defun


@defun mpz-cdiv-q-ui @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-cdiv-q-ui Q N D)))
    (mpz-get-si Q)      @result{} +4
    absR))              @result{} +2
@end lisp
@end defun


@defun mpz-cdiv-r-ui @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-cdiv-r-ui R N D)))
    (mpz-get-si R)      @result{} -2
    absR))              @result{} +2
@end lisp
@end defun


@defun mpz-cdiv-qr-ui @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-cdiv-qr-ui Q R N D)))
    (mpz-get-si Q)      @result{} +4
    (mpz-get-si R)      @result{} -2
    absR))              @result{} +2
@end lisp
@end defun


@defun mpz-cdiv-ui @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((N      (mpz 10))
      (D      3))
  (mpz-cdiv-ui N D))    @result{} +2
@end lisp
@end defun


@defun mpz-cdiv-q-2exp @var{Q} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-cdiv-q-2exp Q N B)
  (mpz-get-si Q))
@result{} +2
@end lisp
@end defun


@defun mpz-cdiv-r-2exp @var{R} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-cdiv-r-2exp R N B)
  (mpz-get-si R))
@result{} -6
@end lisp
@end defun

@c page
@node integers division floor
@subsection Rounding towards -infinity (floor)


For the examples in this section, the template operation is:

@example
N = Q * D + R
@end example

@noindent
and with floor rounding we have:

@example
N = 10
D = 3
Q = floor(N/D) = floor(10 / 3) = floor(3.33333) = 3
R = N - Q * D = 10 - 3 * 3 = +1
@end example

@noindent
for the @code{2exp} functions:

@example
N = 10
B = 3
D = 2^B = 2^3 = 8
Q = floor(N/D) = floor(10 / 8) = floor(1.25) = 1
R = N - Q * D = 10 - 1 * 8 = 10 - 8 = +2
@end example


@defun mpz-fdiv-q @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-fdiv-q Q N D)
  (mpz-get-si Q))
@result{} +3
@end lisp
@end defun


@defun mpz-fdiv-r @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-fdiv-r R N D)
  (mpz-get-si R))
@result{} +1
@end lisp
@end defun


@defun mpz-fdiv-qr @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-fdiv-qr Q R N D)
  (mpz-get-si Q)        @result{} +3
  (mpz-get-si R))       @result{} +1
@end lisp
@end defun


@defun mpz-fdiv-q-ui @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-fdiv-q-ui Q N D)))
    (mpz-get-si Q)      @result{} +3
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-fdiv-r-ui @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-fdiv-r-ui R N D)))
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-fdiv-qr-ui @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-fdiv-qr-ui Q R N D)))
    (mpz-get-si Q)      @result{} +3
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-fdiv-ui @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((N      (mpz 10))
      (D      3))
  (mpz-fdiv-ui N D))
@result{} +1
@end lisp
@end defun


@defun mpz-fdiv-q-2exp @var{Q} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-fdiv-q-2exp Q N B)
  (mpz-get-si Q))
@result{} +1
@end lisp
@end defun


@defun mpz-fdiv-r-2exp @var{R} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-fdiv-r-2exp R N B)
  (mpz-get-si R))
@result{} +2
@end lisp
@end defun

@c page
@node integers division truncate
@subsection Rounding towards zero (truncate)


For the examples in this section, the template operation is:

@example
N = Q * D + R
@end example

@noindent
and with truncate rounding we have:

@example
N = 10
D = 3
Q = truncate(N/D) = truncate(10 / 3) = truncate(3.33333) = 3
R = N - Q * D = 10 - 3 * 3 = +1
@end example

@noindent
for the @code{2exp} functions:

@example
N = 10
B = 3
D = 2^B = 2^3 = 8
Q = truncate(N/D) = truncate(10 / 8) = truncate(1.25) = 1
R = N - Q * D = 10 - 1 * 8 = 10 - 8 = +2
@end example


@defun mpz-tdiv-q @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-tdiv-q Q N D)
  (mpz-get-si Q))
@result{} +3
@end lisp
@end defun


@defun mpz-tdiv-r @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-tdiv-r R N D)
  (mpz-get-si R))
@result{} +1
@end lisp
@end defun


@defun mpz-tdiv-qr @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-tdiv-qr Q R N D)
  (mpz-get-si Q)        @result{} +3
  (mpz-get-si R))       @result{} +1
@end lisp
@end defun


@defun mpz-tdiv-q-ui @var{Q} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-tdiv-q-ui Q N D)))
    (mpz-get-si Q)      @result{} +3
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-tdiv-r-ui @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-tdiv-r-ui R N D)))
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-tdiv-qr-ui @var{Q} @var{R} @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((Q      (mpz))
      (R      (mpz))
      (N      (mpz 10))
      (D      3))
  (let ((absR (mpz-tdiv-qr-ui Q R N D)))
    (mpz-get-si Q)      @result{} +3
    (mpz-get-si R)      @result{} +1
    absR))              @result{} +1
@end lisp
@end defun


@defun mpz-tdiv-ui @var{N} @var{D}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}.

@lisp
(let ((N      (mpz 10))
      (D      3))
  (mpz-tdiv-ui N D))
@result{} +1
@end lisp
@end defun


@defun mpz-tdiv-q-2exp @var{Q} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-tdiv-q-2exp Q N B)
  (mpz-get-si Q))
@result{} +1
@end lisp
@end defun


@defun mpz-tdiv-r-2exp @var{R} @var{N} @var{B}
Divide @var{N} by @var{D}, forming a quotient @var{Q} and/or remainder @var{R}; compute
@var{D} as 2^@var{B}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (B      3))
  (mpz-tdiv-r-2exp R N B)
  (mpz-get-si R))
@result{} +2
@end lisp
@end defun

@c page
@node integers division modulo
@subsection Modulo functions


The following functions use floor rounding, @ref{integers division floor, Rounding towards -infinity
(floor)}.


@defun mpz-mod @var{R} @var{N} @var{D}
Set @var{R} to @var{N} mod @var{D}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      (mpz 3)))
  (mpz-mod R N D)
  (mpz-get-si R))
@result{} 1
@end lisp
@end defun


@defun mpz-mod-ui @var{R} @var{N} @var{D}
Set @var{R} to @var{N} mod @var{D}.

@lisp
(let ((R      (mpz))
      (N      (mpz 10))
      (D      3))
  (mpz-mod-ui R N D))
@result{} 1
@end lisp
@end defun

@c page
@node integers division exact
@subsection Exact division


The following functions will return correct results only when @math{D} is an exact divisor of
@math{N}.


@defun mpz-divexact @var{Q} @var{N} @var{D}
Set @var{Q} to @var{N}/@var{D}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 9))
      (D      (mpz 3)))
  (mpz-divexact Q N D)
  (mpz-get-si Q))
@result{} 3
@end lisp
@end defun


@defun mpz-divexact-ui @var{Q} @var{N} @var{D}
Set @var{Q} to @var{N}/@var{D}.

@lisp
(let ((Q      (mpz))
      (N      (mpz 9))
      (D      3))
  (mpz-divexact-ui Q N D)
  (mpz-get-si Q))
@result{} 3
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Exact division tests


@defun mpz-divisible-p @var{N} @var{D}
Return true if @var{N} is exactly divisible by @var{D}.

@lisp
(let ((N      (mpz 9))
      (D      (mpz 3)))
  (mpz-divisible-p N D))
@result{} t
@end lisp
@end defun


@defun mpz-divisible-ui-p @var{N} @var{D}
Return true if @var{N} is exactly divisible by @var{D}.

@lisp
(let ((N      (mpz 9))
      (D      3))
  (mpz-divisible-ui-p N D))
@result{} t
@end lisp
@end defun


@defun mpz-divisible-2exp-p @var{N} @var{B}
Return true if @var{N} is exactly divisible by 2^@var{B}.

@lisp
(let ((N      (mpz 16))
      (B      3))
  (mpz-divisible-2exp-p N B))
@result{} t
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Congruency tests


@math{N} is congruent to @math{C} modulo @math{D} if there exists an integer @math{Q} satisfying
@math{N = C + Q * D}.


@defun mpz-congruent-p @var{N} @var{C} @var{D}
Return non-zero if @var{N} is congruent to @var{C} modulo @var{D}.

@lisp
(let ((N      (mpz 7))
      (C      (mpz 1))
      (D      (mpz 3)))
  (mpz-congruent-p N C D))
@result{} t
@end lisp
@end defun


@defun mpz-congruent-ui-p @var{N} @var{C} @var{D}
Return non-zero if @var{N} is congruent to @var{C} modulo @var{D}.

@lisp
(let ((N      (mpz 7))
      (C      1)
      (D      3))
  (mpz-congruent-ui-p N C D))
@result{} t
@end lisp
@end defun


@defun mpz-congruent-2exp-p @var{N} @var{C} @var{B}
Return non-zero if @var{N} is congruent to @var{C} modulo 2^@var{B}.

@lisp
(let ((N      (mpz 17))
      (C      (mpz 1))
      (B      3))
  (mpz-congruent-2exp-p N C B))
@result{} t
@end lisp
@end defun

@c page
@node integers exponentiation
@section Exponentiation operations


@defun mpz-powm @var{ROP} @var{BASE} @var{EXP} @var{MOD}
Set @var{ROP} to (@var{BASE} raised to @var{EXP}) modulo @var{MOD}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    (mpz 3))
      (mod    (mpz 2)))
  (mpz-powm rop base exp mod)
  (equal (mod (expt 5 3) 2)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun


@defun mpz-powm-ui @var{ROP} @var{BASE} @var{EXP} @var{MOD}
Set @var{ROP} to (@var{BASE} raised to @var{EXP}) modulo @var{MOD}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    3)
      (mod    (mpz 2)))
  (mpz-powm-ui rop base exp mod)
  (equal (mod (expt 5 3) 2)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun


@defun mpz-powm-sec @var{ROP} @var{BASE} @var{EXP} @var{MOD}
Set @var{ROP} to (@var{BASE} raised to @var{EXP}) modulo @var{MOD}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    (mpz 3))
      (mod    (mpz 7)))
  (mpz-powm-sec rop base exp mod)
  (equal (mod (expt 5 3) 2)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun


@defun mpz-pow-ui @var{ROP} @var{BASE} @var{EXP}
Set @var{ROP} to @var{BASE} raised to @var{EXP}.

@lisp
(let ((rop    (mpz))
      (base   (mpz 5))
      (exp    3))
  (mpz-pow-ui rop base exp)
  (equal (expt 5 3)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun


@defun mpz-ui-pow-ui @var{ROP} @var{BASE} @var{EXP}
Set @var{ROP} to @var{BASE} raised to @var{EXP}.

@lisp
(let ((rop    (mpz))
      (base   5)
      (exp    3))
  (mpz-ui-pow-ui rop base exp)
  (equal (expt 5 3)
         (mpz-get-ui rop)))
@result{} t
@end lisp
@end defun

@c page
@node integers roots
@section Root extraction functions


@deffn {Generic Function} mpz-root (@var{rop} @var{op} @var{N})
@deffnx {Method} mpz-root ((@var{rop} mpz) (@var{op} mpz) (@var{N} integer))
Set @var{ROP} to the truncated integer part of the @var{N}th root of @var{OP}.
@end deffn


@deffn {Generic Function} mpz-rootrem (@var{root} @var{rem} @var{U} @var{N})
@deffnx {Method} mpz-rootrem ((@var{root} mpz) (@var{rem} mpz) (@var{U} mpz) (@var{N} integer))
Set @var{ROOT} to the truncated integer part of the @var{N}th root of @var{U}.  Set @var{REM}to the
remainder, @var{U}-@var{ROOT}^@var{N}.
@end deffn


@deffn {Generic Function} mpz-sqrt (@var{rop} @var{op})
@deffnx {Method} mpz-sqrt ((@var{rop} mpz) (@var{op} mpz))
Set @var{ROP} to the truncated integer part of the square root of @var{OP}.
@end deffn


@deffn {Generic Function} mpz-sqrtrem (@vari{rop} @varii{rop} @var{op})
@deffnx {Method} mpz-sqrtrem ((@vari{rop} mpz) (@var{rop} mpz) (@var{op} mpz))
Set @vari{ROP} to the truncated integer part of the square root of @var{OP}.  Set @varii{ROP} to the
remainder @var{OP}-@vari{ROP}*@vari{ROP}.
@end deffn


@deffn {Generic Function} mpz-perfect-power-p (@var{op})
@deffnx {Method} mpz-perfect-power-p ((@var{op} mpz))
Return true if @var{OP} is a perfect power; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-perfect-square-p (@var{op})
@deffnx {Method} mpz-perfect-square-p ((@var{op} mpz))
Return true if @var{OP} is a perfect square; otherwise return false.
@end deffn

@c page
@node integers comparison
@section Commparison functions


@deffn {Generic Function} mpz-cmp (@vari{op} @varii{op})
@deffnx {Method} mpz-cmp ((@vari{op} mpz) (@varii{op} mpz))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp (mpz 1) (mpz 2))       @result{} -1
(mpz-cmp (mpz 0) (mpz 0))       @result{} 0
(mpz-cmp (mpz 2) (mpz 1))       @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmp-d (@vari{op} @varii{op})
@deffnx {Method} mpz-cmp-d ((@vari{op} mpz) (@varii{op} float))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp-d (mpz 1) 2.0))        @result{} -1
(mpz-cmp-d (mpz 0) 0.0))        @result{} 0
(mpz-cmp-d (mpz 2) 1.0))        @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmp-si (@vari{op} @varii{op})
@deffnx {Method} mpz-cmp-si ((@vari{op} mpz) (@varii{op} integer))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp-si (mpz -2) -1))       @result{} -1
(mpz-cmp-si (mpz  0)  0))       @result{} 0
(mpz-cmp-si (mpz -1) -2))       @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmp-ui (@vari{op} @varii{op})
@deffnx {Method} mpz-cmp-ui ((@vari{op} mpz) (@varii{op} integer))
Compare @vari{OP} and @varii{OP}.

@lisp
(mpz-cmp-ui (mpz 1) 2))         @result{} -1
(mpz-cmp-ui (mpz 0) 0))         @result{} 0
(mpz-cmp-ui (mpz 2) 1))         @result{} +1
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-cmpabs (@vari{op} @varii{op})
@deffnx {Method} mpz-cmpabs ((@vari{op} mpz) (@varii{op} mpz))
Compare the absolute values of OP1 and OP2.

@lisp
(mpz-cmpabs (mpz 1) (mpz -2))   @result{} -1
(mpz-cmpabs (mpz 0) (mpz  0))   @result{} 0
(mpz-cmpabs (mpz 2) (mpz  1))   @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmpabs-d (@vari{op} @varii{op})
@deffnx {Method} mpz-cmpabs-d ((@vari{op} mpz) (@varii{op} float))
Compare the absolute values of OP1 and OP2.

@lisp
(mpz-cmpabs-d (mpz 1) -2.0)     @result{} -1
(mpz-cmpabs-d (mpz 0)  0.0)     @result{} 0
(mpz-cmpabs-d (mpz 2)  1.0)     @result{} +1
@end lisp
@end deffn


@deffn {Generic Function} mpz-cmpabs-ui (@vari{op} @varii{op})
@deffnx {Method} mpz-cmpabs-ui ((@vari{op} mpz) (@varii{op} integer))
Compare the absolute values of OP1 and OP2.

@lisp
(mpz-cmpabs-ui (mpz  1) 2)      @result{} -1
(mpz-cmpabs-ui (mpz  0) 0)      @result{} 0
(mpz-cmpabs-ui (mpz -2) 1)      @result{} +1
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-sgn (@var{op})
@deffnx {Method} mpz-sgn ((@var{op} mpz))
Return an integer representing the sign of the operand.

@lisp
(mpz-sgn (mpz +1))      @result{} +1
(mpz-sgn (mpz  0))      @result{} 0
(mpz-sgn (mpz -1))      @result{} -1
@end lisp
@end deffn

@c page
@node integers miscellaneous
@section Miscellaneous functions


@deffn {Generic Function} mpz-fits-ulong-p (@var{OP})
@deffnx {Method} mpz-fits-ulong-p ((@var{OP} mpz))
Return true if the operand fits an @code{unsigned long int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-slong-p (@var{OP})
@deffnx {Method} mpz-fits-slong-p ((@var{OP} mpz))
Return true if the operand fits a `@code{igned long int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-uint-p (@var{OP})
@deffnx {Method} mpz-fits-uint-p ((@var{OP} mpz))
Return true if the operand fits an @code{unsigned int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-sint-p (@var{OP})
@deffnx {Method} mpz-fits-sint-p ((@var{OP} mpz))
Return true if the operand fits n `@code{igned int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-ushort-p (@var{OP})
@deffnx {Method} mpz-fits-ushort-p ((@var{OP} mpz))
Return true if the operand fits an @code{unsigned short int}; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-fits-sshort-p (@var{OP})
@deffnx {Method} mpz-fits-sshort-p ((@var{OP} mpz))
Return true if the operand fits a @code{signed short int}; otherwise return false.
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-odd-p (@var{OP})
@deffnx {Method} mpz-odd-p ((@var{OP} mpz))
Return true if the operand is odd; otherwise return false.
@end deffn


@deffn {Generic Function} mpz-even-p (@var{OP})
@deffnx {Method} mpz-even-p ((@var{OP} mpz))
Return true if the operand is even; otherwise return false.
@end deffn

@c ------------------------------------------------------------------------

@deffn {Generic Function} mpz-sizeinbase (@var{op} @var{base})
@deffnx {Method} mpz-sizeinbase ((@var{op} mpz) (@var{base} integer))
Return the size of @var{OP} measured in number of digits in the given @var{BASE}.

The argument @var{BASE} can vary from @math{2} to @math{62}.
@end deffn

@c page
@node rationals
@chapter Rational number objects and operations


@deftp {Object Type} mpq
Type of structures representing a multiple precision rational numbers.  It is a wrapper for the C
language type @objtype{mpq_t}.  These objects, and their internal representation, are correctly
garbage collected.
@end deftp


@menu
* rationals allocation::        Allocating rational numbers.
* rationals predicates::        Rational number predicates.
* rationals assignment::        Assigning values to rational
                                number objects.
* rationals conversion::        Converting rational numbers to
                                other objects.
@end menu

@c page
@node rationals allocation
@section Allocating rational numbers


@defun mpq &optional @var{INIT} @var{DENOMINATOR-INIT}
Build and return a new @objtype{mpq} object instance.  When called with no arguments: the object is
uninitialised.

When the @var{INIT} argument is provided and the argument @var{DENOMINATOR-INIT} is not: @var{INIT}
must be an initialisation value for the @objtype{mpq} object.  It can be: a floating--point number;
an @objtype{mpz} object; an @objtype{mpq} object; an @objtype{mpf} object.

@lisp
(let ((op (mpq 1.2)))
  (mpq-get-str 10 op))
@result{} "5404319552844595/4503599627370496"
@end lisp

When both the @var{INIT} and @var{DENOMINATOR-INIT} arguments are provided: they must be
initialisation values for the numerator and the denominator of the new rational number.  They can
be: exact integer numbers.

@lisp
(let ((op (mpq 3 4)))
  (mpq-get-str 10 op))
@result{} "3/4"
@end lisp

When both the @var{INIT} and @var{DENOMINATOR-INIT} arguments are missing: the returned object is
set to zero.

@lisp
(let ((op (mpq)))
  (mpq-get-str 10 op))
@result{} "0"
@end lisp
@end defun

@c page
@node rationals predicates
@section Rational number predicates


@defun mpq-p @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{mpq}; otherwise return @false{}.

@lisp
(mpq-p (mpq))   @result{} t
(mpq-p 123)     @result{} nil
@end lisp
@end defun

@c page
@node rationals assignment
@section Assigning values to rational number objects


@defun mpq-set @var{rop} @var{op}
Assign the value of @var{op} to @var{rop}; both the operands must be of type @objtype{mpq}.

@lisp
(let ((rop (mpq))
      (op  (mpq)))
  (mpq-set-si rop 3 4)
  (mpq-set    op rop)
  (mpq-get-str 10 op))
@result{} "3/4"
@end lisp
@end defun


@defun mpq-set-si @var{rop} @var{numerator-integer} @var{denominator-integer}
Assign the value of the signed exact integer numbers @var{numerator-integer} and
@var{denominator-integer} to the @objtype{mpq} object @var{rop}.

@lisp
(let ((rop (mpq)))
  (mpq-set-si rop 3 4)
  (mpq-get-str 10 rop))
@result{} "3/4"
@end lisp
@end defun


@defun mpq-set-ui @var{rop} @var{numerator-integer} @var{denominator-integer}
Assign the value of the unsigned exact integer numbers @var{numerator-integer} and
@var{denominator-integer} to the @objtype{mpq} object @var{rop}.

@lisp
(let ((rop (mpq)))
  (mpq-set-ui rop 3 4)
  (mpq-get-str 10 rop))
@result{} "3/4"
@end lisp
@end defun


@defun mpq-set-d @var{rop} @var{flo}
Assign the value of a floating--point object to an @objtype{mpq} object.

@lisp
(let ((rop (mpq)))
  (mpq-set-d rop 1.2)
  (mpq-get-str 10 rop))
@result{} "5404319552844595/4503599627370496"
@end lisp
@end defun


@defun mpq-set-z @var{rop} @var{op}
Assign the value of an @objtype{mpz} object to an @objtype{mpq} object.

@lisp
(let ((rop (mpq))
      (op  (mpz 123)))
  (mpq-set-z rop op)
  (mpq-get-str 10 rop))
@result{} "123"
@end lisp
@end defun


@defun mpq-set-f @var{rop} @var{op}
Assign the value of an @objtype{mpf} object to an @objtype{mpq} object.

@lisp
(let ((rop (mpq))
      (op  (mpf 1.2)))
  (mpq-set-f rop op)
  (mpq-get-str 10 rop))
@result{} "5404319552844595/4503599627370496"
@end lisp
@end defun


@defun mpq-set-str @var{rop} @var{str} @var{base}
Assign the value of a string object to an @objtype{mpq} object.  The argument @var{base} must be an
exact integer representing the base of the numeric string representation: @math{0} or a value
between @math{2} and @math{62}.

@lisp
(let ((rop (mpq)))
  (mpq-set-str rop "3/4" 10)
  (mpq-get-str 10 rop))
@end lisp
@end defun


@defun mpq-swap @vari{op} @varii{op}
Swap the values between two @objtype{mpq} objects.

@lisp
(let ((op1 (mpq))
      (op2 (mpq)))
  (mpq-set-si op1 3 4)
  (mpq-set-si op2 5 6)
  (mpq-swap op1 op2)
  (mpq-get-str 10 op2)  @result{} "3/4"
  (mpq-get-str 10 op1)  @result{} "5/6"
  )
@end lisp
@end defun

@c page
@node rationals conversion
@section Converting rational numbers to other objects


@defun mpq-get-d @var{op}
Convert an object @var{op} of type @objtype{mpq} to a floating--point number.

@lisp
(mpq-get-d (mp1 12.3))  @result{} 12.3
@end lisp
@end defun


@defun mpq-get-str @var{base} @var{op}
Convert an object @var{op} of type @objtype{mpq} to a string; return the resulting string.
@var{base} must be an exact integer representing the base of the numeric string representation:
positive between @math{2} and @math{36} or negative between @math{-2} and @math{-36}.

@lisp
(defconst op (mpq))
(mpq-set-si op 17 13)

(mpq-get-str +10 op)    @result{} "17/13"
(mpq-get-str +16 op)    @result{} "11/d"
(mpq-get-str -16 op)    @result{} "11/D"
@end lisp
@end defun

@c page
@node floats
@chapter Floating-point number objects and operations


@deftp {Object Type} mpf
Type of structures representing a multiple precision floating--point numbers.  It is a wrapper for
the C language type @objtype{mpf_t}.  These objects, and their internal representation, are
correctly garbage collected.
@end deftp


@menu
* floats allocation::           Allocating floating-point numbers.
* floats initialisation::       Floating-point numbers initialisation
                                functions.
* floats predicates::           Floating-point number predicates.
* floats assignment::           Assigning values to floating-point
                                number objects.
* floats conversion::           Converting floating-point numbers to
                                other objects.
@end menu

@c page
@node floats allocation
@section Allocating floating--point numbers


@defun mpf &optional @var{INIT}
Build and return a new @objtype{mpf} object instance.  When called with no arguments: the object is
uninitialised.

When the @var{INIT} argument is provided: it must be an initialisation value for the @objtype{mpf}
object.  I can be: an exact integer number; a floating--point number; an @objtype{mpz} object; an
@objtype{mpq} object; an @objtype{mpf} object.

@lisp
(let ((op (mpf 123)))
  (mpf-get-str* 10 5 op))
@result{} "+0.123e+3"
@end lisp

When the @var{INIT} argument is missing: the returned object is set to zero.

@lisp
(let ((op (mpf)))
  (mpf-get-str* 10 5 op))
@result{} "0.0"
@end lisp
@end defun

@c page
@node floats initialisation
@section Floating--point numbers initialisation functions


@defun mpf-set-default-prec @var{prec}
Set the default precision of @objtype{mpf} object to at least @var{prec}, which must be an exact
integer number object.
@end defun


@defun mpf-get-default-prec
Return an exact integer number representing the current default precision of @objtype{mpf} objects.
@end defun


@defun mpf-set-prec @var{rop} @var{prec}
Set the precision of the @objtype{mpf} object @var{rop} to at least @var{prec}, which must be an
exact integer number object.
@end defun


@defun mpf-get-prec @var{rop}
Return an exact integer number representing the precision of the @objtype{mpf} object @var{rop}.
@end defun

@c page
@node floats predicates
@section Floating--point number predicates


@defun mpf-p @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{mpf}; otherwise return @false{}.

@lisp
(mpf-p (mpf))   @result{} t
(mpf-p 123)     @result{} nil
@end lisp
@end defun

@c page
@node floats assignment
@section Assigning values to floating--point number objects


@defun mpf-set @var{rop} @var{op}
Assign the value of @var{op} to @var{rop}; both the operands must be of type @objtype{mpf}.

@lisp
@end lisp
@end defun


@defun mpf-set-si @var{rop} @var{int}
Assign the value of an exact integer object to an @objtype{mpf} object.

@lisp
@end lisp
@end defun


@defun mpf-set-d @var{rop} @var{flo}
Assign the value of a floating--point object to an @objtype{mpf} object.

@lisp
@end lisp
@end defun


@defun mpf-set-z @var{rop} @var{op}
Assign the value of an @objtype{mpz} object to an @objtype{mpf} object.

@lisp
@end lisp
@end defun


@defun mpf-set-q @var{rop} @var{op}
Assign the value of an @objtype{mpq} object to an @objtype{mpf} object.

@lisp
@end lisp
@end defun


@defun mpf-set-str @var{rop} @var{str} @var{base}
Assign the value of a string object to an @objtype{mpf} object.  The argument @var{base} must be an
exact integer representing the base of the numeric string representation: a positive value between
@math{2} and @math{62} or a negative value between @math{-2} and @math{-62}.

@lisp
@end lisp
@end defun


@defun mpf-swap @vari{op} @varii{op}
Swap the values between two @objtype{mpf} objects.

@lisp
@end lisp
@end defun

@c page
@node floats conversion
@section Converting floating--point numbers to other objects


@defun mpf-get-ui @var{op}
Convert an object @var{op} of type @objtype{mpf} to an unsigned exact integer number.

@lisp
(mpf-get-ui (mpf 123))  @result{} 123
@end lisp
@end defun


@defun mpf-get-si @var{op}
Convert an object @var{op} of type @objtype{mpf} to an signed exact integer number.

@lisp
(mpf-get-si (mpf 123))  @result{} 123
@end lisp
@end defun


@defun mpf-get-d @var{op}
Convert an object @var{op} of type @objtype{mpf} to a floating--point number.

@lisp
(mpf-get-d (mpf 123))  @result{} 123.0
@end lisp
@end defun


@defun mpf-get-d-2exp @var{op}
Convert an object @var{op} of type @objtype{mpf} to a floating--point number, yielding the exponent
separately.  The return value is a pair whose car is a floating--point number and whose cdr is the
exponent:

@lisp
(defconst rv (mpf-get-d-2exp (mpf 123)))

rv                                      @result{} (0.9609375 . 7)
(* (car rv) (expt 2 (cdr rv)))          @result{} 123.0
@end lisp
@end defun


@defun mpf-get-str @var{base} @var{ndigits} @var{op}
Convert an object @var{op} of type @objtype{mpf} to a string; return a pair object whose car is a
string representing the mantissa and whose cdr is an exact integer representing the exponent.

The arguments @var{base} must be an exact integer representing the base of the numeric string
representation: positive between @math{+2} and @math{+62} or negative between @math{-2} and
@math{-36}.

The argument @var{ndigits} must be an exact integer representing the number of digits to generate.

@lisp
(let ((op       (mpf 15))
      (ndigits  5))
  (mpf-get-str +10 ndigits op)  @result{} ("15" . 2)
  (mpf-get-str +16 ndigits op)  @result{} ("f"  . 1)
  (mpf-get-str -16 ndigits op)  @result{} ("F"  . 1)
  )

(let ((op       (mpf))
      (ndigits  5))
  (mpf-set-d op 12.34)
  (mpf-get-str +10 ndigits op))
@result{} ("1234" . 2)
@end lisp
@end defun


@defun mpf-get-str* @var{base} @var{ndigits} @var{op}
Convert an object @var{op} of type @objtype{mpf} to a formatted string; return the string.  The
arguments @var{base} and @var{ndigits} are the same as documented for @func{mpf-get-str}.

@lisp
(let ((op       (mpf))
      (ndigits  5))
  (mpf-set-d op +0.001234)
  (mpf-get-str* +10 ndigits op))
@result{} "+0.1234e-2"

(let ((op       (mpf))
      (ndigits  5))
  (mpf-set-d op +12.34)
  (mpf-get-str* +10 ndigits op))
@result{} "+0.1234e+2"

(mpf-get-str* 10 5 (mpf))
@result{} "0.0"
@end lisp
@end defun

@c page
@node errors
@chapter How errors are signalled


Occasionally the functions in @value{PACKAGE} signal an error; the following error symbols are
defined.


@defvr {Error Symbol} mmux-gmp-error
The base type of all the error symbols.
@end defvr


@defvr {Error Symbol} mmux-gmp-invalid-initialisation-value
@defvrx {Parent Error Symbol} mmux-gmp-error
Used to signal an invalid initialisation value for an object constructor.
@end defvr


@defvr {Error Symbol} mmux-gmp-no-memory-error
@defvrx {Parent Error Symbol} mmux-gmp-error
Used to signal that there was not enough memory to allocate an object.
@end defvr


@defvr {Error Symbol} mmux-gmp-string-too-long
@defvrx {Parent Error Symbol} mmux-gmp-error
Used to signal that a string argument is to long to be processed.  As example, this may happen when
converting strings to and from elisp objects.
@end defvr

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

We can find @gmp{} here:

@center @url{https://gmplib.org/}

We can found informations and examples about Emacs modules at the repository mirror, under the
@file{modules} directory:

@center @url{https://github.com/emacs-mirror/emacs}

There is also a list of resources about Emacs modules:

@center @url{https://github.com/emacs-pe/emacs-modules}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

